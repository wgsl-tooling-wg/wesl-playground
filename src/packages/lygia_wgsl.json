{"lygia::color::blend::add":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Add blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendAdd(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendAdd(base: f32, blend: f32) -> f32 { return min(base + blend, 1.0); }\nfn blendAdd3(base: vec3f, blend: vec3f) -> vec3f { return min(base + blend, vec3(1.0)); }\nfn blendAdd3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f { return blendAdd3(base, blend) * opacity + base * (1.0 - opacity); }\n","lygia::color::blend::average":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Average blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendAverage(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendAverage(base : f32, blend : f32) -> f32 { return (base + blend) * 0.5; }\nfn blendAverage3(base : vec3f, blend : vec3f) -> vec3f { return (base + blend) * 0.5; }\nfn blendAverage3Opacity(base : vec3f, blend : vec3f, opacity : f32) -> vec3f { return (blendAverage3(base, blend) * opacity + base * (1.0 - opacity)); }\n","lygia::color::blend::color":"import package::color::space::{rgb2hsv::rgb2hsv, hsv2rgb::hsv2rgb};\n\n/*\ncontributors: Romain Dura\ndescription: Color Blend mode creates the result color by combining the luminance of the base color with the hue and saturation of the blend color.\nuse: blendColor(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendColor(base: vec3f, blend: vec3f) -> vec3f {\n    let baseHSL = rgb2hsv(base);\n    let blendHSL = rgb2hsv(blend);\n\n    return hsv2rgb(vec3f(blendHSL.x, blendHSL.y, baseHSL.z));\n}\n\nfn blendColorOpacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendColor(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::colorBurn":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Color Burn blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorBurn(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendColorBurn(base: f32, blend: f32) -> f32 {\n  return select(max((1.0 - ((1.0 - base) / blend)), 0.0), blend, blend == 0.0);\n}\n\nfn blendColorBurn3(base: vec3f, blend: vec3f) -> vec3f {\n  return vec3f(\n    blendColorBurn(base.r, blend.r),\n    blendColorBurn(base.g, blend.g),\n    blendColorBurn(base.b, blend.b)\n  );\n}\n\nfn blendColorBurn3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n  return blendColorBurn3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::colorDodge":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Color Dodge blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendColorDodge(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendColorDodge(base: f32, blend: f32) -> f32 {\n    return select(min(base / (1.0 - blend), 1.0), blend, blend == 1.0);\n}\n\nfn blendColorDodge3(base: vec3f, blend: vec3f) -> vec3f {\n    return vec3f(\n        blendColorDodge(base.r, blend.r),\n        blendColorDodge(base.g, blend.g),\n        blendColorDodge(base.b, blend.b)\n    );\n}\n\nfn blendColorDodge3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendColorDodge3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::darken":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Darken blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendDarken(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendDarken(base: f32, blend: f32) -> f32 {\n    return min(blend, base);\n}\n\nfn blendDarken3(base: vec3f, blend: vec3f) -> vec3f {\n    return vec3f(\n        blendDarken(base.r, blend.r),\n        blendDarken(base.g, blend.g),\n        blendDarken(base.b, blend.b)\n    );\n}\n\nfn blendDarken3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendDarken3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::difference":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Difference blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendDifference(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendDifference(base: f32, blend: f32) -> f32 {\n    return abs(base - blend);\n}\n\nfn blendDifference3(base: vec3f, blend: vec3f) -> vec3f {\n    return abs(base - blend);\n}\n\nfn blendDifference3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendDifference3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::exclusion":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Exclusion blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendExclusion(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendExclusion(base: f32, blend: f32) -> f32 {\n  return base + blend - 2.0 * base * blend;\n}\n\nfn blendExclusion3(base: vec3f, blend: vec3f) -> vec3f {\n  return base + blend - 2.0 * base * blend;\n}\n\nfn blendExclusion3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n  return blendExclusion3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::glow":"import package::color::blend::reflect::{blendReflect, blendReflect3};\n\n/*\ncontributors: Jamie Owen\ndescription: Photoshop Glow blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendGlow(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendGlow(base: f32, blend: f32) -> f32 {\n    return blendReflect(blend, base);\n}\n\nfn blendGlow3(base: vec3f, blend: vec3f) -> vec3f {\n    return blendReflect3(blend, base);\n}\n\nfn blendGlow3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendGlow3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::hardLight":"import package::color::blend::overlay::blendOverlay;\n\n/*\ncontributors: Jamie Owen\ndescription: Photoshop HardLight blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendHardLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendHardLight(base: f32, blend: f32) -> f32 {\n  return blendOverlay(blend, base);\n}\n\nfn blendHardLight3(base: vec3f, blend: vec3f) -> vec3f {\n  return blendOverlay(blend, base);\n}\n\nfn blendHardLight3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n  return blendHardLight3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::hardMix":"import package::color::blend::vividLight::blendVividLight;\n\n/*\ncontributors: Jamie Owen\ndescription: Photoshop Hard Mix blend mode implementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendHardMix(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendHardMix(base: f32, blend: f32) -> f32 {\n    return select(1.0, 0.0, blendVividLight(base, blend) < 0.5);\n}\n\nfn blendHardMix3(base: vec3f, blend: vec3f) -> vec3f {\n    return vec3f(\n        blendHardMix(base.r, blend.r),\n        blendHardMix(base.g, blend.g),\n      blendHardMix(base.b, blend.b)\n    );\n}\n\nfn blendHardMix3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendHardMix3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::hue":"import package::color::space::{rgb2hsv::rgb2hsv, hsv2rgb::hsv2rgb};\n\n/*\ncontributors: Romain Dura\ndescription: Hue Blend mode creates the result color by combining the luminance and saturation of the base color with the hue of the blend color.\nuse: blendHue(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendHue(base: vec3f, blend: vec3f) -> vec3f {\n    let baseHSV = rgb2hsv(base);\n    let blendHSV = rgb2hsv(blend);\n    return hsv2rgb(vec3f(blendHSV.x, baseHSV.y, baseHSV.z));\n}\n\nfn blendHueOpacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendHue(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::lighten":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Lighten blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLighten(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendLighten(base: f32, blend: f32) -> f32 {\n    return max(blend, base);\n}\n\nfn blendLighten3(base: vec3f, blend: vec3f) -> vec3f {\n    return vec3f(\n        blendLighten(base.r, blend.r),\n        blendLighten(base.g, blend.g),\n        blendLighten(base.b, blend.b)\n    );\n}\n\nfn blendLighten3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendLighten3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::linearBurn":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Linear Burn blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLinearBurn(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendLinearBurn(base: f32, blend: f32) -> f32 {\n    // Note: Same implementation as BlendSubtractf\n    return max(base + blend - 1.0, 0.0);\n}\n\nfn blendLinearBurn3(base: vec3f, blend: vec3f) -> vec3f {\n    // Note: Same implementation as BlendSubtract\n    return max(base + blend - vec3f(1.0), vec3f(0.0));\n}\n\nfn blendLinearBurn3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendLinearBurn3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::linearDodge":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Linear Dodge blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLinearDodge(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendLinearDodge(base: f32, blend: f32) -> f32 {\n    // Note: Same implementation as BlendAddf\n    return min(base + blend, 1.0);\n}\n\nfn blendLinearDodge3(base: vec3f, blend: vec3f) -> vec3f {\n    // Note: Same implementation as BlendAdd\n    return min(base + blend, vec3f(1.0));\n}\n\nfn blendLinearDodge3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendLinearDodge3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::linearLight":"import package::color::blend::linearDodge::blendLinearDodge;\nimport package::color::blend::linearBurn::blendLinearBurn;\n\n/*\ncontributors: Jamie Owen\ndescription: Photoshop Linear Light blend mode implementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendLinearLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendLinearLight(base: f32, blend: f32) -> f32 {\n    return select(blendLinearDodge(base, (blend - 0.5) * 2.0), blendLinearBurn(base, blend * 2.0), blend < 0.5);\n}\n\nfn blendLinearLight3(base: vec3f, blend: vec3f) -> vec3f {\n    return vec3f(\n      blendLinearLight(base.r, blend.r),\n      blendLinearLight(base.g, blend.g),\n      blendLinearLight(base.b, blend.b)\n    );\n}\n\nfn blendLinearLight3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendLinearLight3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::luminosity":"import package::color::space::{rgb2hsv::rgb2hsv, hsv2rgb::hsv2rgb};\n\n/*\ncontributors: Romain Dura\ndescription: Luminosity Blend mode creates the result color by combining the hue and luminance of the base color with the saturation of the blend color.\nuse: blendLuminosity(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendLuminosity(base: vec3f, blend: vec3f) -> vec3f {\n    let baseHSL = rgb2hsv(base);\n    let blendHSL = rgb2hsv(blend);\n    return hsv2rgb(vec3f(baseHSL.x, baseHSL.y, blendHSL.z));\n}\n\nfn blendLuminosityOpacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendLuminosity(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::multiply":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Multiply blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendMultiply(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendMultiply(base: f32, blend: f32) -> f32 {\n    return base * blend;\n}\n\nfn blendMultiply3(base: vec3f, blend: vec3f) -> vec3f {\n    return base * blend;\n}\n\nfn blendMultiply3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return (blendMultiply3(base, blend) * opacity + base * (1. - opacity));\n}\n","lygia::color::blend::negation":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Negation blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendNegation(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendNegation(base: f32, blend: f32) -> f32 {\n    return 1.0 - abs(1.0 - base - blend);\n}\n\nfn blendNegation3(base: vec3f, blend: vec3f) -> vec3f {\n    return vec3f(1.0) - abs(vec3f(1.0) - base - blend);\n}\n\nfn blendNegation3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendNegation3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::overlay":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Overlay blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendOverlay(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendOverlay(base: f32, blend: f32) -> f32 {\n    if (base < 0.5) {\n        return (2.*base*blend);\n    } else {\n        return (1. - 2. * (1. - base) * (1. - blend));\n    }\n}\n\nfn blendOverlay3(base: vec3f, blend: vec3f) -> vec3f {\n    return vec3(blendOverlay(base.r, blend.r),\n                blendOverlay(base.g, blend.g),\n                blendOverlay(base.b, blend.b));\n}\n\nfn blendOverlay3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return (blendOverlay3(base, blend) * opacity + base * (1. - opacity));\n}","lygia::color::blend::phoenix":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Phoenix blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendPhoenix(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendPhoenix(base: f32, blend: f32) -> f32 {\n    return min(base, blend) - max(base, blend) + 1.0;\n}\n\nfn blendPhoenix3(base: vec3f, blend: vec3f) -> vec3f {\n    return min(base, blend) - max(base, blend) + vec3f(1.0);\n}\n\nfn blendPhoenix3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendPhoenix3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::pinLight":"import package::color::blend::lighten::blendLighten;\nimport package::color::blend::darken::blendDarken;\n\n/*\ncontributors: Jamie Owen\ndescription: Photoshop Pin Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendPinLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendPinLight(base: f32, blend: f32) -> f32 {\n    return select(blendLighten(base, (blend - 0.5) * 2.0), blendDarken(base, blend * 2.0), blend < 0.5);\n}\n\nfn blendPinLight3(base: vec3f, blend: vec3f) -> vec3f {\n    return vec3f(\n        blendPinLight(base.r, blend.r),\n        blendPinLight(base.g, blend.g),\n        blendPinLight(base.b, blend.b)\n    );\n}\n\nfn blendPinLight3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendPinLight3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::reflect":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Reflect blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendReflect(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendReflect(base: f32, blend: f32) -> f32 {\n    return select(min(base * base / (1.0 - blend), 1.0), blend, blend == 1.0);\n}\n\nfn blendReflect3(base: vec3f, blend: vec3f) -> vec3f {\n    return vec3f(\n        blendReflect(base.r, blend.r),\n        blendReflect(base.g, blend.g),\n        blendReflect(base.b, blend.b)\n    );\n}\n\nfn blendReflect3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendReflect3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::saturation":"import package::color::space::{rgb2hsv::rgb2hsv, hsv2rgb::hsv2rgb};\n\n/*\ncontributors: Romain Dura\ndescription: Saturation Blend mode creates the result color by combining the hue and luminance of the base color with the saturation of the blend color.\nuse: blendSaturation(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendSaturation(base: vec3f, blend: vec3f) -> vec3f {\n    let baseHSL = rgb2hsv(base);\n    let blendHSL = rgb2hsv(blend);\n    return hsv2rgb(vec3f(baseHSL.x, blendHSL.y, baseHSL.z));\n}\n\nfn blendSaturationOpacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendSaturation(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::screen":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Screen blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendScreen(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendScreen(base: f32, blend: f32) -> f32 {\n    return 1. - ((1. - base) * (1. - blend));\n}\n\nfn blendScreen3(base: vec3f, blend: vec3f) -> vec3f {\n    return vec3f(blendScreen(base.r, blend.r),\n                 blendScreen(base.g, blend.g),\n                 blendScreen(base.b, blend.b));\n}\n\nfn blendScreenWithOpacity3(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return (blendScreen3(base, blend) * opacity + base * (1. - opacity));\n}\n","lygia::color::blend::softLight":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Soft Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendSoftLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\n*/\n\nfn blendSoftLight(base: f32, blend: f32) -> f32 {\n    if (blend < 0.5) {\n        return (2. * base * blend + base * base * (1. - 2.*blend));\n    } else {\n        return (sqrt(base) * (2. * blend - 1.) + 2. * base * (1. - blend));\n    }\n}\n\nfn blendSoftLight3(base: vec3f, blend: vec3f) -> vec3f {\n    return vec3(blendSoftLight(base.r, blend.r),\n                blendSoftLight(base.g, blend.g),\n                blendSoftLight(base.b, blend.b));\n}\n\nfn blendSoftLight4(base: vec4f, blend: vec4f) -> vec4f {\n    return vec4(blendSoftLight( base.r, blend.r ),\n                blendSoftLight( base.g, blend.g ),\n                blendSoftLight( base.b, blend.b ),\n                blendSoftLight( base.a, blend.a )\n    );\n}\n\nfn blendSoftLight3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return (blendSoftLight3(base, blend) * opacity + base * (1. - opacity));\n}\n","lygia::color::blend::subtract":"/*\ncontributors: Jamie Owen\ndescription: Photoshop Soft Light blend mode mplementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendSubtract(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendSubtract(base: f32, blend: f32) -> f32 {\n    return max(base + blend - 1.0, 0.0);\n}\n\nfn blendSubtract3(base: vec3f, blend: vec3f) -> vec3f {\n    return max(base + blend - vec3f(1.0), vec3f(0.0));\n}\n\nfn blendSubtract3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendSubtract3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::blend::vividLight":"import package::color::blend::colorBurn::blendColorBurn;\nimport package::color::blend::colorDodge::blendColorDodge;\n\n/*\ncontributors: Jamie Owen\ndescription: Photoshop Vivid Light blend mode implementations sourced from this article on https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/\nuse: blendVividLight(<float|vec3> base, <float|vec3> blend [, <float> opacity])\nlicense: MIT License (MIT) Copyright (c) 2015 Jamie Owen\n*/\n\nfn blendVividLight(base: f32, blend: f32) -> f32 {\n    return select(blendColorDodge(base, (blend - 0.5) * 2.0), blendColorBurn(base, blend * 2.0), blend < 0.5);\n}\n\nfn blendVividLight3(base: vec3f, blend: vec3f) -> vec3f {\n    return vec3f(\n        blendVividLight(base.r, blend.r),\n        blendVividLight(base.g, blend.g),\n        blendVividLight(base.b, blend.b)\n    );\n}\n\nfn blendVividLight3Opacity(base: vec3f, blend: vec3f, opacity: f32) -> vec3f {\n    return blendVividLight3(base, blend) * opacity + base * (1.0 - opacity);\n}\n","lygia::color::brightnessContrast":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Modify brightness and contrast\nuse: brightnessContrast(<float|vec3|vec4> color, <float> brightness, <float> amcontrastount)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/color_brightnessContrast.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn brightnessContrast(v : f32, b : f32, c : f32) -> f32 { return (v - 0.5) * c + 0.5 + b; }\n\nfn brightnessContrast3(v : vec3f, b : f32, c : f32) -> vec3f { return (v - 0.5) * c + 0.5 + b; }\n\nfn brightnessContrast4(v : vec4f, b : f32, c : f32) -> vec4f { return vec4((v.rgb - 0.5) * c + 0.5 + b, v.a); }\n","lygia::color::distance":"import package::color::space::{\n    rgb2lab::rgb2lab, \n    rgb2YCbCr::rgb2YCbCr, \n    rgb2YPbPr::rgb2YPbPr, \n    rgb2yuv::rgb2yuv, \n    rgb2oklab::rgb2oklab};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Perceptual distance between two color according to CIE94 https://en.wikipedia.org/wiki/Color_difference#CIE94\nuse: colorDistance(<vec3|vec4> rgbA, <vec3|vec4> rgbA)\noptions:\n    - COLORDISTANCE_FNC: |\n        colorDistanceLABCIE94, colorDistanceLAB, colorDistanceYCbCr,\n        colorDistanceYPbPr, colorDistanceYUV, colorDistanceOKLAB\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn colorDistanceLABCIE94(rgb1 : vec3<f32>, rgb2 : vec3<f32>) -> f32 {\n    let lab1 = rgb2lab(rgb1);\n    let lab2 = rgb2lab(rgb2);\n\n    let delta = lab1 - lab2;\n    let c1 = sqrt(lab1.y * lab1.y + lab1.z * lab1.z);\n    let c2 = sqrt(lab2.y * lab2.y + lab2.z * lab2.z);\n    let delta_c = c1 - c2;\n    var delta_h = delta.x * delta.x + delta.z * delta.z - delta_c * delta_c;\n    delta_h = mix(0., sqrt(delta_h), step(0., delta_h));\n\n    let sc = 1. + .045 * c1;\n    let sh = 1. + .015 * c1;\n\n    let delta_ckcsc = delta_c / sc;\n    let delta_hkhsh = delta_h / sh;\n\n    let delta_e = delta.x * delta.x + delta_ckcsc * delta_ckcsc + delta_hkhsh * delta_hkhsh;\n    return mix(0., sqrt(delta_e), step(0., delta_e));\n}\n\nfn colorDistanceLAB(rgb1 : vec3<f32>, rgb2 : vec3<f32>) -> f32 {\n    return distance(rgb2lab(rgb1), rgb2lab(rgb2));\n}\nfn colorDistanceYCbCr(rgb1 : vec3<f32>, rgb2 : vec3<f32>) -> f32 {\n    return distance(rgb2YCbCr(rgb1).yz, rgb2YCbCr(rgb2).yz);\n}\nfn colorDistanceYPbPr(rgb1 : vec3<f32>, rgb2 : vec3<f32>) -> f32 {\n    return distance(rgb2YPbPr(rgb1).yz, rgb2YPbPr(rgb2).yz);\n}\nfn colorDistanceYUV(rgb1 : vec3<f32>, rgb2 : vec3<f32>) -> f32 {\n    return distance(rgb2yuv(rgb1), rgb2yuv(rgb2));\n}\nfn colorDistanceOKLAB(rgb1 : vec3<f32>, rgb2 : vec3<f32>) -> f32 {\n    return distance(rgb2oklab(rgb1), rgb2oklab(rgb2));\n}\n","lygia::color::dither::bayer":"import package::math::decimate::decimate3;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Dither using a 8x8 Bayer matrix\nuse:\n    - <vec4|vec3|float> ditherBayer(<vec4|vec3|float> value, <vec2> st, <float> time)\n    - <vec4|vec3|float> ditherBayer(<vec4|vec3|float> value, <vec2> st)\n    - <float> ditherBayer(<vec2> xy)\noptions:\n    - DITHER_BAKER_COORD\nexamples:\n    - /shaders/color_dither_bayer.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn mod_fract(a: vec2f, b: f32) -> vec2f { return modf(a / b).fract * b; }\n\nconst indexMatrix4x4 = array<f32, 16>(0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5);\n\nfn indexValue4(fragCoord: vec2<f32>) -> f32 {\n    let p = vec2<i32>(mod_fract(fragCoord, 4));\n    return indexMatrix4x4[(p.x + p.y * 4)] / 16.0;\n}\n\nconst indexMatrix8x8 =\n    array<f32, 64>(0, 32, 8, 40, 2, 34, 10, 42, 48, 16, 56, 24, 50, 18, 58, 26, 12, 44, 4, 36, 14, 46, 6, 38, 60, 28,\n    52, 20, 62, 30, 54, 22, 3, 35, 11, 43, 1, 33, 9, 41, 51, 19, 59, 27, 49, 17, 57, 25, 15, 47, 7, 39,\n    13, 45, 5, 37, 63, 31, 55, 23, 61, 29, 53, 21);\n\nfn indexValue8(fragCoord: vec2<f32>) -> f32 {\n    let p = vec2<i32>(mod_fract(fragCoord, 8));\n    return indexMatrix8x8[(p.x + p.y * 8)] / 64.0;\n}\n\nfn ditherBayer1(ist: vec2f) -> f32 { return indexValue4(ist); }\n\nfn ditherBayer3(color: vec3f, xy: vec2f, d: vec3f) -> vec3f {\n    let decimated = decimate3(color, d);\n    let diff = (color - decimated) * d;\n    let ditherPattern = vec3(ditherBayer1(xy));\n    return decimate3(color + (step(ditherPattern, diff) / d), d);\n}\n","lygia::color::dither::blueNoise":"import package::math::decimate::decimate3;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: blue noise dithering\nuse:\n    - <vec4|vec3|float> ditherBlueNoise(<vec4|vec3|float> value, <vec2> st, <float> time)\n    - <vec4|vec3|float> ditherBlueNoise(<vec4|vec3|float> value, <float> time)\noptions:\n    - SAMPLER_FNC\n    - BLUENOISE_TEXTURE\n    - BLUENOISE_TEXTURE_RESOLUTION\n    - DITHER_BLUENOISE_CHROMATIC\n    - DITHER_BLUENOISE_TIME\nexamples:\n    - /shaders/color_dither.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n\n// Somehow not as good?\nfn ditherBlueNoise2(inp: vec2f) -> f32 {\n    let SEED1 = 1.705;\n    let size = 5.5;\n    var p = floor(inp);\n    var p1 = p;\n    p += 1337.0 * fract(uniforms.frameIdx * 0.1);\n    // p += 10.0;\n    p = floor(p / size) * size;\n    p = fract(p * 0.1) + 1.0 + p * vec2(0.0002, 0.0003);\n    var a = fract(1.0 / (0.000001 * p.x * p.y + 0.00001));\n    a = fract(1.0 / (0.000001234 * a + 0.00001));\n    var b = fract(1.0 / (0.000002 * (p.x * p.y + p.x) + 0.00001));\n    b = fract(1.0 / (0.0000235 * b + 0.00001));\n    let r = vec2(a, b) - 0.5;\n    p1 += r * 8.12235325;\n\n    return fract(p1.x * SEED1 + p1.y / (SEED1 + 0.15555));\n}\n\nfn ditherBlueNoise3(color: vec3f, xy: vec2f, d: vec3f) -> vec3f {\n    let decimated = decimate3(color, d);\n    let diff = (color - decimated) * d;\n    return decimate3(color + step(vec3(ditherBlueNoise2(xy)), diff) / d, d);\n}\n","lygia::color::dither::vlachos":"import package::math::decimate::decimate3;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: 'Vlachos 2016, \"Advanced VR Rendering\" http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf'\nuse: <vec4|vec3|float> ditherVlachos(<vec4|vec3|float> value, <float> time)\noptions:\n    - DITHER_VLACHOS_TIME\n    - DITHER_VLACHOS_CHROMATIC\nexamples:\n    - /shaders/color_dither.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn ditherVlachos1(ist: vec2f) -> vec3f {\n    var st = ist;\n    st += 1337.0 * fract(uniforms.frameIdx);\n    var noise = vec3(dot(vec2(171.0, 231.0), st));\n    noise = fract(noise / vec3(103.0, 71.0, 97.0));\n    return noise;\n}\n\nfn ditherVlachos3(color: vec3f, st: vec2f, d: vec3f) -> vec3f {\n    let ditherPattern = ditherVlachos1(st);\n    return decimate3(color + ditherPattern / d, d);\n}","lygia::color::exposure":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Change the exposure of a color\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn exposure3(color : vec3f, amount : f32) -> vec3f { return color * pow(2., amount); }\n\nfn exposure4(color : vec4f, amount : f32) -> vec4f { return vec4(exposure3(color.rgb, amount), color.a); }\n","lygia::color::hueShift":"import package::color::space::{hsl2rgb::hsl2rgb, rgb2hsl::rgb2hsl};\n\n/*\ncontributors:\n    - Johan Ismael\n    - Patricio Gonzalez Vivo\ndescription: Shifts color hue\nuse: <vec3f> hueShift(<vec3f> color, <float> angle)\noptionas:\n    - HUESHIFT_AMOUNT: if defined, it uses a normalized value instead of an angle\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn hueShift(color: vec3f, a: f32 ) -> vec3f{\n    var hsl = rgb2hsl(color);\n    hsl.r = hsl.r * TAU + a;\n    hsl.r = fract(hsl.r / TAU);\n    return hsl2rgb(hsl);\n}\n","lygia::color::hueShiftRYB":"import package::color::hueShift::hueShift;\nimport package::color::space::{rgb2ryb::rgb2ryb, ryb2rgb::ryb2rgb};\nimport package::math::consts::PI;\n\n/*\ncontributors:\n    - Johan Ismael\n    - Patricio Gonzalez Vivo\ndescription: Shifts color hue in the RYB color space\nuse: hueShift(<vec3|vec4> color, <float> angle)\noptionas:\n    - HUESHIFT_AMOUNT: if defined, it uses a normalized value instead of an angle\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/color_ryb.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn hueShiftRYB(color: vec3f, a: f32) -> vec3f {\n    var rgb = rgb2ryb(color);\n    rgb = hueShift(rgb, PI);\n    return ryb2rgb(rgb);\n}\n","lygia::color::luma":"import package::color::space::rgb2luma::rgb2luma;\n\n/*\ncontributors: Hugh Kennedy (https://github.com/hughsk)\ndescription: Get the luminosity of a color. From https://github.com/hughsk/glsl-luma/blob/master/index.glsl\n*/\n\nfn luma(color: vec3f) -> f32 {\n    return rgb2luma(color);\n}\n","lygia::color::mixOklab":"import package::color::space::rgb2oklab::RGB2OKLAB_B;\nimport package::color::space::oklab2rgb::OKLAB2RGB_B;\n\n/*\ncontributors:\n    - Bjorn Ottosson\n    - Inigo Quiles\ndescription: |\n    Mix function by Inigo Quiles (https://www.shadertoy.com/view/ttcyRS) \n    utilizing Bjorn Ottosso's OkLab color space, which is provide smooth stransitions \n    Learn more about it [his article](https://bottosson.github.io/posts/oklab/)\noptions:\n    - MIXOKLAB_SRGB: by default colA and colB use linear RGB. If you want to use sRGB define this flag\nexamples:\n    - /shaders/color_mix.frag\nlicense: \n    - MIT License (MIT) Copyright (c) 2020 BjÃ¶rn Ottosson\n    - MIT License (MIT) Copyright (c) 2020 Inigo Quilez\n*/\n\nfn mixOklab( colA: vec3f, colB: vec3f, h: f32 ) -> vec3f {\n    \n    // rgb to cone (arg of pow can't be negative)\n    let lmsA = pow( RGB2OKLAB_B*colA, vec3f(0.33333) );\n    let lmsB = pow( RGB2OKLAB_B*colB, vec3f(0.33333) );\n\n    let lms = mix( lmsA, lmsB, h );\n\n    // cone to rgb\n    return OKLAB2RGB_B*(lms*lms*lms);\n}\n","lygia::color::mixSpectral":"import package::color::space::xyz2srgb::XYZ2RGB;\n\n/*\ncontributors: Ronald van Wijnen (@OneDayOfCrypto)\ndescription: | \n    Spectral mix allows you to achieve realistic color mixing in your projects. \n    It is based on the Kubelka-Munk theory, a proven scientific model that simulates \n    how light interacts with paint to produce lifelike color mixing. \n    Find more information on Ronald van Wijnen's [original repository](https://github.com/rvanwijnen/spectral.js)\noptions:\n    - MIXSPECTRAL_SRGB: by default A and B are linear RGB. If you want to use sRGB, define this flag.\nexamples:\n    - /shaders/color_mix.frag\nlicense: MIT License Copyright (c) 2023 Ronald van Wijnen\n*/\n\nconst MIXSPECTRAL_EPSILON = 0.0001;\n\nfn mixSpectral_linear_to_reflectance(rgb: vec3f) -> array<f32,38> {\n    var R: array<f32,38>;\n    var lrgb = rgb;\n\n    let w = min(lrgb.r, min(lrgb.g, lrgb.b));\n    lrgb -= w;\n\n    let c = min(lrgb.g, lrgb.b);\n    let m = min(lrgb.r, lrgb.b);\n    let y = min(lrgb.r, lrgb.g);\n\n    let r = min(max(0.0, lrgb.r - lrgb.b), max(0.0, lrgb.r - lrgb.g));\n    let g = min(max(0.0, lrgb.g - lrgb.b), max(0.0, lrgb.g - lrgb.r));\n    let b = min(max(0.0, lrgb.b - lrgb.g), max(0.0, lrgb.b - lrgb.r));\n    \n    R[ 0] = max(MIXSPECTRAL_EPSILON, w + c * 0.96853629 + m * 0.51567122 + y * 0.02055257 + r * 0.03147571 + g * 0.49108579 + b * 0.97901834);\n    R[ 1] = max(MIXSPECTRAL_EPSILON, w + c * 0.96855103 + m * 0.54015520 + y * 0.02059936 + r * 0.03146636 + g * 0.46944057 + b * 0.97901649);\n    R[ 2] = max(MIXSPECTRAL_EPSILON, w + c * 0.96859338 + m * 0.62645502 + y * 0.02062723 + r * 0.03140624 + g * 0.40165780 + b * 0.97901118);\n    R[ 3] = max(MIXSPECTRAL_EPSILON, w + c * 0.96877345 + m * 0.75595012 + y * 0.02073387 + r * 0.03119611 + g * 0.24490420 + b * 0.97892146);\n    R[ 4] = max(MIXSPECTRAL_EPSILON, w + c * 0.96942204 + m * 0.92826996 + y * 0.02114202 + r * 0.03053888 + g * 0.06826880 + b * 0.97858555);\n    R[ 5] = max(MIXSPECTRAL_EPSILON, w + c * 0.97143709 + m * 0.97223624 + y * 0.02233154 + r * 0.02856855 + g * 0.02732883 + b * 0.97743705);\n    R[ 6] = max(MIXSPECTRAL_EPSILON, w + c * 0.97541862 + m * 0.98616174 + y * 0.02556857 + r * 0.02459485 + g * 0.01360600 + b * 0.97428075);\n    R[ 7] = max(MIXSPECTRAL_EPSILON, w + c * 0.98074186 + m * 0.98955255 + y * 0.03330189 + r * 0.01929520 + g * 0.01000187 + b * 0.96663223);\n    R[ 8] = max(MIXSPECTRAL_EPSILON, w + c * 0.98580992 + m * 0.98676237 + y * 0.05185294 + r * 0.01423112 + g * 0.01284127 + b * 0.94822893);\n    R[ 9] = max(MIXSPECTRAL_EPSILON, w + c * 0.98971194 + m * 0.97312575 + y * 0.10087639 + r * 0.01033111 + g * 0.02636635 + b * 0.89937713);\n    R[10] = max(MIXSPECTRAL_EPSILON, w + c * 0.99238027 + m * 0.91944277 + y * 0.24000413 + r * 0.00765876 + g * 0.07058713 + b * 0.76070164);\n    R[11] = max(MIXSPECTRAL_EPSILON, w + c * 0.99409844 + m * 0.32564851 + y * 0.53589066 + r * 0.00593693 + g * 0.70421692 + b * 0.46420440);\n    R[12] = max(MIXSPECTRAL_EPSILON, w + c * 0.99517200 + m * 0.13820628 + y * 0.79874659 + r * 0.00485616 + g * 0.85473994 + b * 0.20123039);\n    R[13] = max(MIXSPECTRAL_EPSILON, w + c * 0.99576545 + m * 0.05015143 + y * 0.91186529 + r * 0.00426186 + g * 0.95081565 + b * 0.08808402);\n    R[14] = max(MIXSPECTRAL_EPSILON, w + c * 0.99593552 + m * 0.02912336 + y * 0.95399623 + r * 0.00409039 + g * 0.97170370 + b * 0.04592894);\n    R[15] = max(MIXSPECTRAL_EPSILON, w + c * 0.99564041 + m * 0.02421691 + y * 0.97137099 + r * 0.00438375 + g * 0.97651888 + b * 0.02860373);\n    R[16] = max(MIXSPECTRAL_EPSILON, w + c * 0.99464769 + m * 0.02660696 + y * 0.97939505 + r * 0.00537525 + g * 0.97429245 + b * 0.02060067);\n    R[17] = max(MIXSPECTRAL_EPSILON, w + c * 0.99229579 + m * 0.03407586 + y * 0.98345207 + r * 0.00772962 + g * 0.97012917 + b * 0.01656701);\n    R[18] = max(MIXSPECTRAL_EPSILON, w + c * 0.98638762 + m * 0.04835936 + y * 0.98553736 + r * 0.01366120 + g * 0.94258630 + b * 0.01451549);\n    R[19] = max(MIXSPECTRAL_EPSILON, w + c * 0.96829712 + m * 0.00011720 + y * 0.98648905 + r * 0.03181352 + g * 0.99989207 + b * 0.01357964);\n    R[20] = max(MIXSPECTRAL_EPSILON, w + c * 0.89228016 + m * 0.00008554 + y * 0.98674535 + r * 0.10791525 + g * 0.99989891 + b * 0.01331243);\n    R[21] = max(MIXSPECTRAL_EPSILON, w + c * 0.53740239 + m * 0.85267882 + y * 0.98657555 + r * 0.46249516 + g * 0.13823139 + b * 0.01347661);\n    R[22] = max(MIXSPECTRAL_EPSILON, w + c * 0.15360445 + m * 0.93188793 + y * 0.98611877 + r * 0.84604333 + g * 0.06968113 + b * 0.01387181);\n    R[23] = max(MIXSPECTRAL_EPSILON, w + c * 0.05705719 + m * 0.94810268 + y * 0.98559942 + r * 0.94275572 + g * 0.05628787 + b * 0.01435472);\n    R[24] = max(MIXSPECTRAL_EPSILON, w + c * 0.03126539 + m * 0.94200977 + y * 0.98507063 + r * 0.96860996 + g * 0.06111561 + b * 0.01479836);\n    R[25] = max(MIXSPECTRAL_EPSILON, w + c * 0.02205445 + m * 0.91478045 + y * 0.98460039 + r * 0.97783966 + g * 0.08987709 + b * 0.01515250);\n    R[26] = max(MIXSPECTRAL_EPSILON, w + c * 0.01802271 + m * 0.87065445 + y * 0.98425301 + r * 0.98187757 + g * 0.13656016 + b * 0.01540513);\n    R[27] = max(MIXSPECTRAL_EPSILON, w + c * 0.01613460 + m * 0.78827548 + y * 0.98403909 + r * 0.98377315 + g * 0.22169624 + b * 0.01557233);\n    R[28] = max(MIXSPECTRAL_EPSILON, w + c * 0.01520947 + m * 0.65738359 + y * 0.98388535 + r * 0.98470202 + g * 0.32176956 + b * 0.01565710);\n    R[29] = max(MIXSPECTRAL_EPSILON, w + c * 0.01475977 + m * 0.59909403 + y * 0.98376116 + r * 0.98515481 + g * 0.36157329 + b * 0.01571025);\n    R[30] = max(MIXSPECTRAL_EPSILON, w + c * 0.01454263 + m * 0.56817268 + y * 0.98368246 + r * 0.98537114 + g * 0.48361920 + b * 0.01571916);\n    R[31] = max(MIXSPECTRAL_EPSILON, w + c * 0.01444459 + m * 0.54031997 + y * 0.98365023 + r * 0.98546685 + g * 0.46488579 + b * 0.01572133);\n    R[32] = max(MIXSPECTRAL_EPSILON, w + c * 0.01439897 + m * 0.52110241 + y * 0.98361309 + r * 0.98550011 + g * 0.47440306 + b * 0.01572502);\n    R[33] = max(MIXSPECTRAL_EPSILON, w + c * 0.01437620 + m * 0.51041094 + y * 0.98357259 + r * 0.98551031 + g * 0.48576990 + b * 0.01571717);\n    R[34] = max(MIXSPECTRAL_EPSILON, w + c * 0.01436343 + m * 0.50526577 + y * 0.98353856 + r * 0.98550741 + g * 0.49267971 + b * 0.01571905);\n    R[35] = max(MIXSPECTRAL_EPSILON, w + c * 0.01435687 + m * 0.50255080 + y * 0.98351247 + r * 0.98551323 + g * 0.49625685 + b * 0.01571059);\n    R[36] = max(MIXSPECTRAL_EPSILON, w + c * 0.01435370 + m * 0.50126452 + y * 0.98350101 + r * 0.98551563 + g * 0.49807754 + b * 0.01569728);\n    R[37] = max(MIXSPECTRAL_EPSILON, w + c * 0.01435408 + m * 0.50083021 + y * 0.98350852 + r * 0.98551547 + g * 0.49889859 + b * 0.01570020);\n\n    return R;\n}\n\nfn mixSpectral_reflectance_to_xyz(R: array<f32,38>) -> vec3f {\n    return  R[ 0] * vec3f(0.00006469, 0.00000184, 0.00030502) +\n            R[ 1] * vec3f(0.00021941, 0.00000621, 0.00103681) +\n            R[ 2] * vec3f(0.00112057, 0.00003101, 0.00531314) +\n            R[ 3] * vec3f(0.00376661, 0.00010475, 0.01795439) +\n            R[ 4] * vec3f(0.01188055, 0.00035364, 0.05707758) +\n            R[ 5] * vec3f(0.02328644, 0.00095147, 0.11365162) +\n            R[ 6] * vec3f(0.03455942, 0.00228226, 0.17335873) +\n            R[ 7] * vec3f(0.03722379, 0.00420733, 0.19620658) +\n            R[ 8] * vec3f(0.03241838, 0.00668880, 0.18608237) +\n            R[ 9] * vec3f(0.02123321, 0.00988840, 0.13995048) +\n            R[10] * vec3f(0.01049099, 0.01524945, 0.08917453) +\n            R[11] * vec3f(0.00329584, 0.02141831, 0.04789621) +\n            R[12] * vec3f(0.00050704, 0.03342293, 0.02814563) +\n            R[13] * vec3f(0.00094867, 0.05131001, 0.01613766) +\n            R[14] * vec3f(0.00627372, 0.07040208, 0.00775910) +\n            R[15] * vec3f(0.01686462, 0.08783871, 0.00429615) +\n            R[16] * vec3f(0.02868965, 0.09424905, 0.00200551) +\n            R[17] * vec3f(0.04267481, 0.09795667, 0.00086147) +\n            R[18] * vec3f(0.05625475, 0.09415219, 0.00036904) +\n            R[19] * vec3f(0.06947040, 0.08678102, 0.00019143) +\n            R[20] * vec3f(0.08305315, 0.07885653, 0.00014956) +\n            R[21] * vec3f(0.08612610, 0.06352670, 0.00009231) +\n            R[22] * vec3f(0.09046614, 0.05374142, 0.00006813) +\n            R[23] * vec3f(0.08500387, 0.04264606, 0.00002883) +\n            R[24] * vec3f(0.07090667, 0.03161735, 0.00001577) +\n            R[25] * vec3f(0.05062889, 0.02088521, 0.00000394) +\n            R[26] * vec3f(0.03547396, 0.01386011, 0.00000158) +\n            R[27] * vec3f(0.02146821, 0.00810264, 0.00000000) +\n            R[28] * vec3f(0.01251646, 0.00463010, 0.00000000) +\n            R[29] * vec3f(0.00680458, 0.00249138, 0.00000000) +\n            R[30] * vec3f(0.00346457, 0.00125930, 0.00000000) +\n            R[31] * vec3f(0.00149761, 0.00054165, 0.00000000) +\n            R[32] * vec3f(0.00076970, 0.00027795, 0.00000000) +\n            R[33] * vec3f(0.00040737, 0.00014711, 0.00000000) +\n            R[34] * vec3f(0.00016901, 0.00006103, 0.00000000) +\n            R[35] * vec3f(0.00009522, 0.00003439, 0.00000000) +\n            R[36] * vec3f(0.00004903, 0.00001771, 0.00000000) +\n            R[37] * vec3f(0.00002000, 0.00000722, 0.00000000);\n}\n\nfn mixSpectral(A: vec3f, B: vec3f, pct: f32) -> vec3f {\n    let R1 = mixSpectral_linear_to_reflectance(A);\n    let R2 = mixSpectral_linear_to_reflectance(B);\n        \n    let l1 = mixSpectral_reflectance_to_xyz(R1)[1];\n    let l2 = mixSpectral_reflectance_to_xyz(R2)[1];\n    let t1 = l1 * pow(1.0 - pct, 2.0);\n    let t2 = l2 * pow(pct, 2.0);\n    var t = t2 / (t1 + t2);\n    \n    var R: array<f32,38>;\n    let KS0 = (1.0 - t) * (pow(1.0 - R1[0], 2.0) / (2.0 * R1[0])) + t * (pow(1.0 - R2[0], 2.0) / (2.0 * R2[0]));\n    R[0] = 1.0 + KS0 - sqrt(pow(KS0, 2.0) + 2.0 * KS0);\n    let KS1 = (1.0 - t) * (pow(1.0 - R1[1], 2.0) / (2.0 * R1[1])) + t * (pow(1.0 - R2[1], 2.0) / (2.0 * R2[1]));\n    R[1] = 1.0 + KS1 - sqrt(pow(KS1, 2.0) + 2.0 * KS1);\n    let KS2 = (1.0 - t) * (pow(1.0 - R1[2], 2.0) / (2.0 * R1[2])) + t * (pow(1.0 - R2[2], 2.0) / (2.0 * R2[2]));\n    R[2] = 1.0 + KS2 - sqrt(pow(KS2, 2.0) + 2.0 * KS2);\n    let KS3 = (1.0 - t) * (pow(1.0 - R1[3], 2.0) / (2.0 * R1[3])) + t * (pow(1.0 - R2[3], 2.0) / (2.0 * R2[3]));\n    R[3] = 1.0 + KS3 - sqrt(pow(KS3, 2.0) + 2.0 * KS3);\n    let KS4 = (1.0 - t) * (pow(1.0 - R1[4], 2.0) / (2.0 * R1[4])) + t * (pow(1.0 - R2[4], 2.0) / (2.0 * R2[4]));\n    R[4] = 1.0 + KS4 - sqrt(pow(KS4, 2.0) + 2.0 * KS4);\n    let KS5 = (1.0 - t) * (pow(1.0 - R1[5], 2.0) / (2.0 * R1[5])) + t * (pow(1.0 - R2[5], 2.0) / (2.0 * R2[5]));\n    R[5] = 1.0 + KS5 - sqrt(pow(KS5, 2.0) + 2.0 * KS5);\n    let KS6 = (1.0 - t) * (pow(1.0 - R1[6], 2.0) / (2.0 * R1[6])) + t * (pow(1.0 - R2[6], 2.0) / (2.0 * R2[6]));\n    R[6] = 1.0 + KS6 - sqrt(pow(KS6, 2.0) + 2.0 * KS6);\n    let KS7 = (1.0 - t) * (pow(1.0 - R1[7], 2.0) / (2.0 * R1[7])) + t * (pow(1.0 - R2[7], 2.0) / (2.0 * R2[7]));\n    R[7] = 1.0 + KS7 - sqrt(pow(KS7, 2.0) + 2.0 * KS7);\n    let KS8 = (1.0 - t) * (pow(1.0 - R1[8], 2.0) / (2.0 * R1[8])) + t * (pow(1.0 - R2[8], 2.0) / (2.0 * R2[8]));\n    R[8] = 1.0 + KS8 - sqrt(pow(KS8, 2.0) + 2.0 * KS8);\n    let KS9 = (1.0 - t) * (pow(1.0 - R1[9], 2.0) / (2.0 * R1[9])) + t * (pow(1.0 - R2[9], 2.0) / (2.0 * R2[9]));\n    R[9] = 1.0 + KS9 - sqrt(pow(KS9, 2.0) + 2.0 * KS9);\n    let KS10 = (1.0 - t) * (pow(1.0 - R1[10], 2.0) / (2.0 * R1[10])) + t * (pow(1.0 - R2[10], 2.0) / (2.0 * R2[10]));\n    R[10] = 1.0 + KS10 - sqrt(pow(KS10, 2.0) + 2.0 * KS10);\n    let KS11 = (1.0 - t) * (pow(1.0 - R1[11], 2.0) / (2.0 * R1[11])) + t * (pow(1.0 - R2[11], 2.0) / (2.0 * R2[11]));\n    R[11] = 1.0 + KS11 - sqrt(pow(KS11, 2.0) + 2.0 * KS11);\n    let KS12 = (1.0 - t) * (pow(1.0 - R1[12], 2.0) / (2.0 * R1[12])) + t * (pow(1.0 - R2[12], 2.0) / (2.0 * R2[12]));\n    R[12] = 1.0 + KS12 - sqrt(pow(KS12, 2.0) + 2.0 * KS12);\n    let KS13 = (1.0 - t) * (pow(1.0 - R1[13], 2.0) / (2.0 * R1[13])) + t * (pow(1.0 - R2[13], 2.0) / (2.0 * R2[13]));\n    R[13] = 1.0 + KS13 - sqrt(pow(KS13, 2.0) + 2.0 * KS13);\n    let KS14 = (1.0 - t) * (pow(1.0 - R1[14], 2.0) / (2.0 * R1[14])) + t * (pow(1.0 - R2[14], 2.0) / (2.0 * R2[14]));\n    R[14] = 1.0 + KS14 - sqrt(pow(KS14, 2.0) + 2.0 * KS14);\n    let KS15 = (1.0 - t) * (pow(1.0 - R1[15], 2.0) / (2.0 * R1[15])) + t * (pow(1.0 - R2[15], 2.0) / (2.0 * R2[15]));\n    R[15] = 1.0 + KS15 - sqrt(pow(KS15, 2.0) + 2.0 * KS15);\n    let KS16 = (1.0 - t) * (pow(1.0 - R1[16], 2.0) / (2.0 * R1[16])) + t * (pow(1.0 - R2[16], 2.0) / (2.0 * R2[16]));\n    R[16] = 1.0 + KS16 - sqrt(pow(KS16, 2.0) + 2.0 * KS16);\n    let KS17 = (1.0 - t) * (pow(1.0 - R1[17], 2.0) / (2.0 * R1[17])) + t * (pow(1.0 - R2[17], 2.0) / (2.0 * R2[17]));\n    R[17] = 1.0 + KS17 - sqrt(pow(KS17, 2.0) + 2.0 * KS17);\n    let KS18 = (1.0 - t) * (pow(1.0 - R1[18], 2.0) / (2.0 * R1[18])) + t * (pow(1.0 - R2[18], 2.0) / (2.0 * R2[18]));\n    R[18] = 1.0 + KS18 - sqrt(pow(KS18, 2.0) + 2.0 * KS18);\n    let KS19 = (1.0 - t) * (pow(1.0 - R1[19], 2.0) / (2.0 * R1[19])) + t * (pow(1.0 - R2[19], 2.0) / (2.0 * R2[19]));\n    R[19] = 1.0 + KS19 - sqrt(pow(KS19, 2.0) + 2.0 * KS19);\n    let KS20 = (1.0 - t) * (pow(1.0 - R1[20], 2.0) / (2.0 * R1[20])) + t * (pow(1.0 - R2[20], 2.0) / (2.0 * R2[20]));\n    R[20] = 1.0 + KS20 - sqrt(pow(KS20, 2.0) + 2.0 * KS20);\n    let KS21 = (1.0 - t) * (pow(1.0 - R1[21], 2.0) / (2.0 * R1[21])) + t * (pow(1.0 - R2[21], 2.0) / (2.0 * R2[21]));\n    R[21] = 1.0 + KS21 - sqrt(pow(KS21, 2.0) + 2.0 * KS21);\n    let KS22 = (1.0 - t) * (pow(1.0 - R1[22], 2.0) / (2.0 * R1[22])) + t * (pow(1.0 - R2[22], 2.0) / (2.0 * R2[22]));\n    R[22] = 1.0 + KS22 - sqrt(pow(KS22, 2.0) + 2.0 * KS22);\n    let KS23 = (1.0 - t) * (pow(1.0 - R1[23], 2.0) / (2.0 * R1[23])) + t * (pow(1.0 - R2[23], 2.0) / (2.0 * R2[23]));\n    R[23] = 1.0 + KS23 - sqrt(pow(KS23, 2.0) + 2.0 * KS23);\n    let KS24 = (1.0 - t) * (pow(1.0 - R1[24], 2.0) / (2.0 * R1[24])) + t * (pow(1.0 - R2[24], 2.0) / (2.0 * R2[24]));\n    R[24] = 1.0 + KS24 - sqrt(pow(KS24, 2.0) + 2.0 * KS24);\n    let KS25 = (1.0 - t) * (pow(1.0 - R1[25], 2.0) / (2.0 * R1[25])) + t * (pow(1.0 - R2[25], 2.0) / (2.0 * R2[25]));\n    R[25] = 1.0 + KS25 - sqrt(pow(KS25, 2.0) + 2.0 * KS25);\n    let KS26 = (1.0 - t) * (pow(1.0 - R1[26], 2.0) / (2.0 * R1[26])) + t * (pow(1.0 - R2[26], 2.0) / (2.0 * R2[26]));\n    R[26] = 1.0 + KS26 - sqrt(pow(KS26, 2.0) + 2.0 * KS26);\n    let KS27 = (1.0 - t) * (pow(1.0 - R1[27], 2.0) / (2.0 * R1[27])) + t * (pow(1.0 - R2[27], 2.0) / (2.0 * R2[27]));\n    R[27] = 1.0 + KS27 - sqrt(pow(KS27, 2.0) + 2.0 * KS27);\n    let KS28 = (1.0 - t) * (pow(1.0 - R1[28], 2.0) / (2.0 * R1[28])) + t * (pow(1.0 - R2[28], 2.0) / (2.0 * R2[28]));\n    R[28] = 1.0 + KS28 - sqrt(pow(KS28, 2.0) + 2.0 * KS28);\n    let KS29 = (1.0 - t) * (pow(1.0 - R1[29], 2.0) / (2.0 * R1[29])) + t * (pow(1.0 - R2[29], 2.0) / (2.0 * R2[29]));\n    R[29] = 1.0 + KS29 - sqrt(pow(KS29, 2.0) + 2.0 * KS29);\n    let KS30 = (1.0 - t) * (pow(1.0 - R1[30], 2.0) / (2.0 * R1[30])) + t * (pow(1.0 - R2[30], 2.0) / (2.0 * R2[30]));\n    R[30] = 1.0 + KS30 - sqrt(pow(KS30, 2.0) + 2.0 * KS30);\n    let KS31 = (1.0 - t) * (pow(1.0 - R1[31], 2.0) / (2.0 * R1[31])) + t * (pow(1.0 - R2[31], 2.0) / (2.0 * R2[31]));\n    R[31] = 1.0 + KS31 - sqrt(pow(KS31, 2.0) + 2.0 * KS31);\n    let KS32 = (1.0 - t) * (pow(1.0 - R1[32], 2.0) / (2.0 * R1[32])) + t * (pow(1.0 - R2[32], 2.0) / (2.0 * R2[32]));\n    R[32] = 1.0 + KS32 - sqrt(pow(KS32, 2.0) + 2.0 * KS32);\n    let KS33 = (1.0 - t) * (pow(1.0 - R1[33], 2.0) / (2.0 * R1[33])) + t * (pow(1.0 - R2[33], 2.0) / (2.0 * R2[33]));\n    R[33] = 1.0 + KS33 - sqrt(pow(KS33, 2.0) + 2.0 * KS33);\n    let KS34 = (1.0 - t) * (pow(1.0 - R1[34], 2.0) / (2.0 * R1[34])) + t * (pow(1.0 - R2[34], 2.0) / (2.0 * R2[34]));\n    R[34] = 1.0 + KS34 - sqrt(pow(KS34, 2.0) + 2.0 * KS34);\n    let KS35 = (1.0 - t) * (pow(1.0 - R1[35], 2.0) / (2.0 * R1[35])) + t * (pow(1.0 - R2[35], 2.0) / (2.0 * R2[35]));\n    R[35] = 1.0 + KS35 - sqrt(pow(KS35, 2.0) + 2.0 * KS35);\n    let KS36 = (1.0 - t) * (pow(1.0 - R1[36], 2.0) / (2.0 * R1[36])) + t * (pow(1.0 - R2[36], 2.0) / (2.0 * R2[36]));\n    R[36] = 1.0 + KS36 - sqrt(pow(KS36, 2.0) + 2.0 * KS36);\n    let KS37 = (1.0 - t) * (pow(1.0 - R1[37], 2.0) / (2.0 * R1[37])) + t * (pow(1.0 - R2[37], 2.0) / (2.0 * R2[37]));\n    R[37] = 1.0 + KS37 - sqrt(pow(KS37, 2.0) + 2.0 * KS37);\n\n    return XYZ2RGB * mixSpectral_reflectance_to_xyz(R);\n}\n","lygia::color::palette::heatmap":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Heatmap palette\nexamples:\n    - https://raw.githubusercontent.com/eduardfossas/lygia-study-examples/main/color/palette/heatmap.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn heatmap(v: f32) -> vec3f{\n    let r = v * 2.1 - vec3f(1.8, 1.14, 0.3);\n    return 1.0 - r * r;\n}\n","lygia::color::palette::hue":"import package::math::mod::mod3;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: \"Physical Hue. \\n\\nRatio: \\n* 1/3 = neon\\n* 1/4 = refracted\\n* 1/5+ =\\ approximate white\\n\"\nexamples:\n    - https://raw.githubusercontent.com/eduardfossas/lygia-study-examples/main/color/palette/hue.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn hue(x: f32, r: f32) -> vec3f { \n    let v = abs( mod3(x + vec3f(0.0,1.0,2.0) * r, vec3f(1.0)) * 2.0 - 1.0);\n    return v * v * (3.0 - 2.0 * v);\n}\n","lygia::color::saturationMatrix":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Generate a matrix to change a the saturation of any color\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn saturationMatrix(amount : f32) -> mat3x3<f32> {\n    let lum = vec3f(0.3086, 0.6094, 0.0820 );\n    let invAmount = 1.0 - amount;\n    return mat3x3<f32>( vec3f(lum.x * invAmount) + vec3f(amount, .0, .0),\n                        vec3f(lum.y * invAmount) + vec3f( .0, amount, .0),\n                        vec3f(lum.z * invAmount) + vec3f( .0, .0, amount) );\n}\n","lygia::color::space::YCbCr2rgb":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts YCbCr to RGB according to https://en.wikipedia.org/wiki/YCbCr\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn YCbCr2rgb(ycbcr: vec3f) -> vec3f {\n    let cb = ycbcr.y - 0.5;\n    let cr = ycbcr.z - 0.5;\n    let y = ycbcr.x;\n    let r = 1.402 * cr;\n    let g = -0.344 * cb - 0.714 * cr;\n    let b = 1.772 * cb;\n    return vec3f(r, g, b) + y;\n}\n","lygia::color::space::YPbPr2rgb":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Pass a color in RGB and get it in YPbPr from http://www.equasys.de/colorconversion.html\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n// YPBPR_SDTV\n// const YPBPR2RGB = mat3x3<f32>( \n//     vec3f(1.0,     1.0,      1.0),\n//     vec3f(0.0,    -0.344,    1.772),\n//     vec3f(1.402,  -0.714,    0.0)\n// );\n\nconst YPBPR2RGB = mat3x3<f32>( \n    vec3f(1.0,     1.0,      1.0),\n    vec3f(0.0,    -0.187,    1.856),\n    vec3f(1.575,  -0.468,    0.0)\n);\n\nfn YPbPr2rgb(rgb: vec3f) -> vec3f { return YPBPR2RGB * rgb; }\n","lygia::color::space::cmyk2rgb":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Convert CMYK to RGB\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn cmyk2rgb(cmyk: vec4f) -> vec3f {\n    let invK: f32 = 1.0 - cmyk.w;\n    return saturate(1.0 - min(vec3f(1.0), cmyk.xyz * invK + cmyk.w));\n}\n","lygia::color::space::gamma2linear":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Convert from gamma to linear color space.\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn gamma2linear(gamma: vec3f) -> vec3f {\n    return pow(gamma, vec3(2.2));\n}\n","lygia::color::space::hcy2rgb":"import package::color::space::hue2rgb::hue2rgb;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts a HCY color to linear RGB\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn hcy2rgb(hcy: vec3f) -> vec3f {\n    var rta = hcy;\n    let HCYwts = vec3f(0.299, 0.587, 0.114);\n    let RGB = hue2rgb(hcy.x);\n    let Z = dot(RGB, HCYwts);\n    if (hcy.z < Z) {\n        rta.y *= hcy.z / Z;\n    } else if (Z < 1.0) {\n        rta.y *= (1.0 - hcy.z) / (1.0 - Z);\n    }\n    return (RGB - Z) * rta.y + rta.z;\n}\n","lygia::color::space::hsl2rgb":"import package::color::space::hue2rgb::hue2rgb;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts a HSL color to linear RGB\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn hsl2rgb(hsl: vec3f) -> vec3f {\n    let rgb = hue2rgb(hsl.x);\n    let C = (1.0 - abs(2.0 * hsl.z - 1.0)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n","lygia::color::space::hsv2rgb":"import package::color::space::hue2rgb::hue2rgb;\n\n/*\ncontributors: Inigo Quiles\ndescription: 'Convert from HSV to linear RGB'\n\n*/\n\nfn hsv2rgb(hsv : vec3f) -> vec3f {\n    return ((hue2rgb(hsv.x) - 1.0) * hsv.y + 1.0) * hsv.z;\n}\n","lygia::color::space::hsv2ryb":"import package::color::space::{hsv2rgb::hsv2rgb, ryb2rgb::ryb2rgb};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Convert from HSV to RYB color space\nuse: <vec3> hsv2ryb(<vec3> hsv)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/color_ryb.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn hsv2ryb(v: vec3f) -> vec3f {\n    let rgb = hsv2rgb(v);\n    return ryb2rgb(rgb) - saturate(1.-v.z);\n}","lygia::color::space::hue2rgb":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts a hue value to a RGB vec3 color.\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn hue2rgb(hue: f32) -> vec3f {\n    let R = abs(hue * 6.0 - 3.0) - 1.0;\n    let G = 2.0 - abs(hue * 6.0 - 2.0);\n    let B = 2.0 - abs(hue * 6.0 - 4.0);\n    return saturate(vec3f(R,G,B));\n}\n","lygia::color::space::k2rgb":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Blackbody in kelvin to RGB. Range between 0.0 and 40000.0 Kelvin\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn k2rgb(t : f32) -> vec3f {\n    let p = pow(t, -1.5);\n    let l = log(t);\n    var color = vec3f(\n        220000.0 * p + 0.5804,\n        0.3923 * l - 2.4431,\n        0.7615 * l - 5.681\n    );\n\n    if (t > 6500.0) {\n        color.g = 138039.0 * p + 0.738;\n    }\n\n    color = saturate(color);\n    if (t < 1000.0) {\n        color *= t/1000.0;\n    }\n\n    return color;\n}\n","lygia::color::space::lab2lch":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: \"Converts a LCh to Lab color space. \\nNote: LCh is simply Lab but converted to polar coordinates (in degrees).\\n\"\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn lab2lch(lab: vec3f) -> vec3f {\n    return vec3f(\n        lab.x,\n        sqrt(dot(lab.yz, lab.yz)),\n        atan(lab.z, lab.y) * 57.2957795131\n    );\n}","lygia::color::space::lab2rgb":"import package::color::space::{lab2xyz::lab2xyz, xyz2rgb::xyz2rgb};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: |\n    Converts a Lab color to RGB color space. https://en.wikipedia.org/wiki/CIELAB_color_space\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn lab2rgb(lab: vec3f) -> vec3f { return xyz2rgb( lab2xyz( lab ) ); }\n","lygia::color::space::lab2srgb":"import package::color::space::lab2xyz::lab2xyz;\nimport package::color::space::xyz2srgb::xyz2srgb;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: 'Converts a Lab color to RGB color space. https://en.wikipedia.org/wiki/CIELAB_color_space'\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn lab2srgb(lab: vec3f) -> vec3f { return xyz2srgb( lab2xyz( lab ) ); }\n","lygia::color::space::lab2xyz":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: 'Converts a Lab color to XYZ color space. https://en.wikipedia.org/wiki/CIELAB_color_space'\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn lab2xyz(c : vec3f) -> vec3f {\n    var f = vec3f(0.0);\n    f.y = (c.x + 16.0) / 116.0;\n    f.x = c.y / 500.0 + f.y;\n    f.z = f.y - c.z / 200.0;\n    let c0 = f * f * f;\n    let c1 = (f - 16.0 / 116.0) / 7.787;\n    return vec3f(95.047, 100.000, 108.883) * mix(c0, c1, step(f, vec3f(0.206897)));\n}\n","lygia::color::space::lch2lab":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: \"Converts a Lch to Lab color space. \\nNote: LCh is simply Lab but converted to polar coordinates (in degrees).\\n\"\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn lch2lab(lch: vec3f) -> vec3f {\n    return vec3f(\n        lch.x,\n        lch.y * cos(lch.z * 0.01745329251),\n        lch.y * sin(lch.z * 0.01745329251)\n    );\n}\n","lygia::color::space::lch2rgb":"import package::color::space::{lch2lab::lch2lab, lab2rgb::lab2rgb};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: \"Converts a Lch to linear RGB color space. \\nNote: LCh is simply Lab but converted to polar coordinates (in degrees).\\n\"\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn lch2rgb(lch: vec3f) -> vec3f { return lab2rgb( lch2lab(lch) ); }\n","lygia::color::space::linear2gamma":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Convert from linear to gamma color space.\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn linear2gamma(v : vec3f) -> vec3f {\n    return pow(v, vec3f(1. / 2.2));\n}\n","lygia::color::space::lms2rgb":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: \"Convert LST to RGB. LMS (long, medium, short), is a color space which\\\n    \\ represents the response of the three types of cones of the human eye, named for\\\n    \\ their responsivity (sensitivity) peaks at long, medium, and short wavelengths.\\\n    \\ \\nRefs https://en.wikipedia.org/wiki/LMS_color_space https://arxiv.org/pdf/1711.10662\\n\"\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n// const LMS2RGB = mat3x3<f32>(\n//     vec3f(2.85847e+0, -1.62879e+0, -2.48910e-2),\n//     vec3f(-2.10182e-1,  1.15820e+0,  3.24281e-4),\n//     vec3f(-4.18120e-2, -1.18169e-1,  1.06867e+0)\n// );\n\nconst LMS2RGB = mat3x3<f32>(\n    vec3f( 0.0809444479,  -0.0102485335,  -0.000365296938),\n    vec3f(-0.13050440,     0.0540193266,  -0.00412161469),\n    vec3f( 0.116721066,   -0.113614708,    0.693511405)\n);\n\nfn lms2rgb(lms : vec3f) -> vec3f { return LMS2RGB * lms; }\n","lygia::color::space::oklab2rgb":"/*\ncontributors: Bjorn Ottosson (@bjornornorn)\ndescription: Oklab to linear RGB https://bottosson.github.io/posts/oklab/\nlicense: \n    - MIT License (MIT) Copyright (c) 2020 BjÃ¶rn Ottosson\n*/\n\nconst OKLAB2RGB_A : mat3x3<f32>  = mat3x3<f32>(\n    vec3f(1.0, 1.0, 1.0),\n    vec3f(0.3963377774, -0.1055613458, -0.0894841775),\n    vec3f(0.2158037573, -0.0638541728, -1.2914855480) );\n\nconst OKLAB2RGB_B : mat3x3<f32>  = mat3x3<f32>(\n    vec3f(4.0767416621, -1.2684380046, -0.0041960863),\n    vec3f(-3.3077115913, 2.6097574011, -0.7034186147),\n    vec3f(0.2309699292, -0.3413193965, 1.7076147010) );\n\nfn oklab2rgb(oklab: vec3f) -> vec3f {\n    let lms = OKLAB2RGB_A * oklab;\n    return OKLAB2RGB_B * (lms * lms * lms);\n}\n","lygia::color::space::oklab2srgb":"import package::color::space::{oklab2rgb::oklab2rgb, rgb2srgb::rgb2srgb};\n\n/*\ncontributors: Bjorn Ottosson (@bjornornorn)\ndescription: oklab to sRGB https://bottosson.github.io/posts/oklab/\nuse: <vec3\\vec4> oklab2rgb(<vec3|vec4> oklab)\nlicense: \n    - MIT License (MIT) Copyright (c) 2020 BjÃ¶rn Ottosson\n*/\n\nfn oklab2srgb(oklab: vec3f) -> vec3f { return rgb2srgb(oklab2rgb(oklab)); }\n","lygia::color::space::rgb2YCbCr":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Convert RGB to YCbCr according to https://en.wikipedia.org/wiki/YCbCr\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rgb2YCbCr(rgb: vec3f) -> vec3f {\n    let y = dot(rgb, vec3f(0.299, 0.587, 0.114));\n    let cb = 0.5 + dot(rgb, vec3f(-0.168736, -0.331264, 0.5));\n    let cr = 0.5 + dot(rgb, vec3f(0.5, -0.418688, -0.081312));\n    return vec3f(y, cb, cr);\n}\n","lygia::color::space::rgb2YPbPr":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Pass a color in RGB and get it in YPbPr from http://www.equasys.de/colorconversion.html\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n// #ifdef YPBPR_SDTV\n// const RGB2YPBPR = mat3x3<f32>( \n//     vec3f(0.299, -0.169,  0.5),\n//     vec3f(0.587, -0.331, -0.419),\n//     vec3f(0.114,  0.5,   -0.081)\n// );\n// #else\nconst RGB2YPBPR = mat3x3<f32>( \n    vec3f(0.2126, -0.1145721060573399,   0.5),\n    vec3f(0.7152, -0.3854278939426601,  -0.4541529083058166),\n    vec3f(0.0722,  0.5,                 -0.0458470916941834)\n);\n// #endif\n\nfn rgb2YPbPr(rgb: vec3f) -> vec3f { return RGB2YPBPR * rgb; }\n","lygia::color::space::rgb2cmyk":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Convert CMYK to RGB\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rgb2cmyk(rgb: vec3f) -> vec4f {\n    let k = min(1.0 - rgb.r, min(1.0 - rgb.g, 1.0 - rgb.b));\n    let invK = 1.0 - k;\n    var cmy = (1.0 - rgb - k) / invK;\n    cmy *= step(0.0, invK);\n    return saturate(vec4f(cmy, k));\n}\n","lygia::color::space::rgb2hcv":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: 'Convert from RGB to HCV (Hue, Chroma, Value). Based on work by Sam Hocevar and Emil Persson'\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rgb2hcv(rgb: vec3f) -> vec3f {\n    var P: vec4f;\n    if (rgb.g < rgb.b) {\n        P = vec4f(rgb.bg, -1.0, 2.0/3.0);\n    } else {\n        P = vec4f(rgb.gb, 0.0, -1.0/3.0);\n    }\n    var Q: vec4f;\n    if (rgb.r < P.x) {\n        Q = vec4f(P.xyw, rgb.r);\n    } else {\n        Q = vec4f(rgb.r, P.yzx);\n    }\n    let C = Q.x - min(Q.w, Q.y);\n    let H = abs((Q.w - Q.y) / (6.0 * C + 1e-10) + Q.z);\n    return vec3f(H, C, Q.x);\n}\n","lygia::color::space::rgb2hcy":"import package::color::space::{rgb2hcv::rgb2hcv, hue2rgb::hue2rgb};\n\n/*\ncontributors:\n    - David Schaeffer\n    - tobspr\n    - Patricio Gonzalez Vivo\ndescription: 'Convert from linear RGB to HCY (Hue, Chroma, Luminance)\n\n  HCY is a cylindrica. From: https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl'\nlicense:\n    - MIT License (MIT) Copyright (c) 2015 tobspr\n*/\n\nconst HCY_EPSILON = 1e-10;\n\nfn rgb2hcy(rgb: vec3f) -> vec3f {\n    let HCYwts = vec3f(0.299, 0.587, 0.114);\n    // Corrected by David Schaeffer\n    var HCV = rgb2hcv(rgb);\n    let Y = dot(rgb, HCYwts);\n    let Z = dot(hue2rgb(HCV.x), HCYwts);\n    if (Y < Z) {\n        HCV.y *= Z / (HCY_EPSILON + Y);\n    } else {\n        HCV.y *= (1.0 - Z) / (HCY_EPSILON + 1.0 - Y);\n    }\n    return vec3f(HCV.x, HCV.y, Y);\n}\n","lygia::color::space::rgb2heat":"import package::color::space::rgb2hue::rgb2hue;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts a RGB rainbow pattern back to a single float value\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n\nfn rgb2heat(c: vec3f) -> f32 { return 1.025 - rgb2hue(c) * 1.538461538; }\n","lygia::color::space::rgb2hsl":"import package::color::space::rgb2hcv::rgb2hcv;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: 'Convert from linear RGB to HSL. Based on work by Sam Hocevar and Emil Persson'\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rgb2hsl(rgb: vec3f) -> vec3f {\n    let HCV = rgb2hcv(rgb);\n    let L = HCV.z - HCV.y * 0.5;\n    let S = HCV.y / (1.0 - abs(L * 2.0 - 1.0) + 1e-10);\n    return vec3f(HCV.x, S, L);\n}\n","lygia::color::space::rgb2hsv":"/*\ncontributors: Sam Hocevar\ndescription: Pass a color in RGB and get HSB color. From http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n*/\n\nfn rgb2hsv(c: vec3f) -> vec3f {\n    let K = vec4f(0.0, -0.33333333333333333333, 0.6666666666666666666, -1.0);\n    let p = mix(vec4f(c.bg, K.wz), vec4f(c.gb, K.xy), step(c.b, c.g));\n    let q = mix(vec4f(p.xyw, c.r), vec4f(c.r, p.yzx), step(p.x, c.r));\n    let d = q.x - min(q.w, q.y);\n    let e = 1.0e-10;\n    return vec3f(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}","lygia::color::space::rgb2hue":"/*\ncontributors:\n    - Sam Hocevar\n    - Patricio Gonzalez Vivo\ndescription: Convert a color from RGB to HSL color space.\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rgb2hue(rgb: vec3f) -> f32 {\n    let K = vec4f(0.0, -0.33333333333333333333, 0.6666666666666666666, -1.0);\n    var p: vec4f;\n    if (rgb.g < rgb.b) {\n        p = vec4f(rgb.bg, K.wz);\n    } else {\n        p = vec4f(rgb.gb, K.xy);\n    }\n\n    var q: vec4f;\n    if (rgb.r < p.x) {\n        q = vec4f(p.xyw, rgb.r);\n    } else {\n        q = vec4f(rgb.r, p.yzx);\n    }\n    let d = q.x - min(q.w, q.y);\n    return abs(q.z + (q.w - q.y) / (6. * d + 1e-10));\n}\n","lygia::color::space::rgb2lab":"import package::color::space::{rgb2xyz::rgb2xyz, xyz2lab::xyz2lab};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts a RGB color to Lab color space.\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rgb2lab(rgb: vec3f ) -> vec3f { return xyz2lab(rgb2xyz(rgb)); }\n","lygia::color::space::rgb2lch":"import package::color::space::rgb2lab::rgb2lab;\nimport package::color::space::lab2lch::lab2lch;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts a RGB color to LCh color space.\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rgb2lch(rgb: vec3f) -> vec3f { return lab2lch(rgb2lab(rgb)); }","lygia::color::space::rgb2lms":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: \"Convert rgb to LMS. LMS (long, medium, short), is a color space which\\\n    \\ represents the response of the three types of cones of the human eye, named for\\\n    \\ their responsivity (sensitivity) peaks at long, medium, and short wavelengths.\\\n    \\ \\nRefs https://en.wikipedia.org/wiki/LMS_color_space https://arxiv.org/pdf/1711.10662\\n\"\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n// const RGB2LMS = mat3x3<f32>(\n//     vec3f(3.90405e-1, 5.49941e-1, 8.92632e-3),\n//     vec3f(7.08416e-2, 9.63172e-1, 1.35775e-3),\n//     vec3f(2.31082e-2, 1.28021e-1, 9.36245e-1)\n// );\n\nconst RGB2LMS = mat3x3<f32>(\n    vec3f(17.8824,  3.45565,  0.0299566),\n    vec3f(43.5161, 27.1554,   0.184309),\n    vec3f(4.11935,  0.184309, 1.46709)\n);\n\nfn rgb2lms(rgb: vec3f) -> vec3f { return RGB2LMS * rgb; }\n","lygia::color::space::rgb2luma":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Gets the luminosity from linear RGB, based on Rec709 luminance (see https://en.wikipedia.org/wiki/Grayscale)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rgb2luma(rgb: vec3f) -> f32 { return dot(rgb, vec3(0.2126, 0.7152, 0.0722)); }","lygia::color::space::rgb2oklab":"/*\ncontributors: Bjorn Ottosson (@bjornornorn)\ndescription: |\n    Linear rgb to OKLab https://bottosson.github.io/posts/oklab/\nuse: <vec3\\vec4> rgb2oklab(<vec3|vec4> rgb)\nlicense:\n    - MIT License (MIT) Copyright (c) 2020 BjÃ¶rn Ottosson\n*/\n\nconst RGB2OKLAB_A : mat3x3<f32>  = mat3x3<f32>( vec3f(0.2104542553, 1.9779984951, 0.0259040371),\n                                                vec3f(0.7936177850, -2.4285922050, 0.7827717662),\n                                                vec3f(-0.0040720468, 0.4505937099, -0.8086757660) );\n\nconst RGB2OKLAB_B : mat3x3<f32>  = mat3x3<f32>( vec3f(0.4122214708, 0.2119034982, 0.0883024619),\n                                                vec3f(0.5363325363, 0.6806995451, 0.2817188376),\n                                                vec3f(0.0514459929, 0.1073969566, 0.6299787005) );\n\nfn rgb2oklab(rgb: vec3f) -> vec3f {\n    let lms = RGB2OKLAB_B * rgb;\n    return RGB2OKLAB_A * (sign(lms) * pow(abs(lms), vec3f(0.3333333333333)));\n}\n","lygia::color::space::rgb2ryb":"import package::math::cubicMix3::cubicMix3;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts a color from RGB to RYB color space. Based on http://nishitalab.org/user/UEI/publication/Sugita_IWAIT2015.pdf\nuse: <vec3f> ryb2rgb(<vec3f> ryb)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/color_ryb.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rgb2ryb(rgb: vec3f) -> vec3f {\n    let rgb000 = vec3f(1., 1., 1.);       // Black\n    let rgb100 = vec3f(1., 0., 0.);       // Red\n    let rgb010 = vec3f(0., 1., .483);     // Green\n    let rgb110 = vec3f(0., 1., 0.);       // Yellow\n    let rgb001 = vec3f(0., 0., 1.);       // Blue\n    let rgb101 = vec3f(.309, 0., .469);   // Magenta\n    let rgb011 = vec3f(0., .053, .210);   // Turquoise\n    let rgb111 = vec3f(0., 0., 0.);       // White\n    return cubicMix3(\n        cubicMix3(\n            cubicMix3(rgb000, rgb001, vec3f(rgb.z)),\n            cubicMix3(rgb010, rgb011, vec3f(rgb.z)),\n            vec3f(rgb.y)),\n        cubicMix3(\n            cubicMix3(rgb100, rgb101, vec3f(rgb.z)),\n            cubicMix3(rgb110, rgb111, vec3f(rgb.z)),\n            vec3f(rgb.y)),\n        vec3f(rgb.x));\n}\n","lygia::color::space::rgb2srgb":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts a linear RGB color to sRGB.\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rgb2srgb_mono(channel: f32) -> f32 {\n    if (channel < 0.0031308) {\n        return 12.92 * channel;\n    }\n    else {\n        return (1.055) * pow(channel, 0.4166666666666667) - 0.055;\n    }\n}\n\nfn rgb2srgb(rgb: vec3f) -> vec3f {\n    return saturate(vec3(rgb2srgb_mono(rgb.r), rgb2srgb_mono(rgb.g), rgb2srgb_mono(rgb.b)));\n}\n","lygia::color::space::rgb2xyY":"import package::color::space::rgb2xyz::rgb2xyz;\nimport package::color::space::xyz2xyY::xyz2xyY;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts a linear RGB color to xyY color space.\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rgb2xyY(rgb: vec3f) -> vec3f { return xyz2xyY(rgb2xyz(rgb)); }\n","lygia::color::space::rgb2xyz":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: 'Converts a linear RGB color to XYZ color space. Based on http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html'\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n// #ifdef CIE_D50\n// const mat3 RGB2XYZ = mat3(\n//     0.4360747, 0.2225045, 0.0139322,\n//     0.3850649, 0.7168786, 0.0971045,\n//     0.1430804, 0.0606169, 0.7141733);\n// #else\nconst RGB2XYZ = mat3x3<f32>(\n    0.4124564, 0.2126729, 0.0193339,\n    0.3575761, 0.7151522, 0.1191920,\n    0.1804375, 0.0721750, 0.9503041 );\n// #endif\n// #endif\n\nfn rgb2xyz(rgb: vec3f) -> vec3f { return RGB2XYZ * rgb; }\n","lygia::color::space::rgb2yiq":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: \"Convert from linear RGB to YIQ which was the following range. \\nUsing conversion matrices from FCC NTSC Standard (SMPTE C) https://en.wikipedia.org/wiki/YIQ\\n\"\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nconst RGB2YIQ : mat3x3<f32>  = mat3x3<f32>(\n    vec3f(0.300,  0.5900,  0.1100),\n    vec3f(0.599, -0.2773, -0.3217),\n    vec3f(0.213, -0.5251,  0.3121) );\n\nfn rgb2yiq(rgb : vec3f) -> vec3f { return RGB2YIQ * rgb; }\n","lygia::color::space::rgb2yuv":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Pass a color in RGB and get it in YUB\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n// #ifdef YUV_SDTV\n// const RGB2YUV = mat3x3<f32>(\n//     vec3f(0.299, -0.14713,  0.615),\n//     vec3f(0.587, -0.28886, -0.51499),\n//     vec3f(0.114,  0.436,   -0.10001)\n// );\n// #else\nconst RGB2YUV = mat3x3<f32>(\n    vec3f(0.2126,  -.09991, .615),\n    vec3f(0.7152,  -.33609,-.55861),\n    vec3f(0.0722,   .426,  -.05639)\n);\n// #endif\n\nfn rgb2yuv(rgb: vec3f) -> vec3f {\n    return RGB2YUV * rgb;\n}\n","lygia::color::space::ryb2rgb":"import package::math::cubicMix::cubicMix3;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Convert from RYB to RGB color space. Based on http://nishitalab.org/user/UEI/publication/Sugita_IWAIT2015.pdf http://vis.computer.org/vis2004/DVD/infovis/papers/gossett.pdf\nuse: <vec3> ryb2rgb(<vec3> ryb)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/color_ryb.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn ryb2rgb(ryb: vec3f) -> vec3f {\n    let ryb000 = vec3f(1., 1., 1.);       // White\n    let ryb001 = vec3f(.163, .373, .6);   // Blue\n    let ryb010 = vec3f(1., 1., 0.);       // Yellow\n    let ryb100 = vec3f(1., 0., 0.);       // Red\n    let ryb011 = vec3f(0., .66, .2);      // Green\n    let ryb101 = vec3f(.5, 0., .5);       // Violet\n    let ryb110 = vec3f(1., .5, 0.);       // Orange\n    let ryb111 = vec3f(0., 0., 0.);       // Black\n    return \n        cubicMix3(\n            cubicMix3(\n                cubicMix3(ryb000, ryb001, vec3f(ryb.z)),\n                cubicMix3(ryb010, ryb011, vec3f(ryb.z)),\n                vec3f(ryb.y)\n            ), \n            cubicMix3(\n                cubicMix3(ryb100, ryb101, ryb.z),\n                cubicMix3(ryb110, ryb111, ryb.z),\n                vec3f(ryb.y)\n            ), \n            vec3f(ryb.x)\n        );\n}\n","lygia::color::space::srgb2lab":"import package::color::space::{rgb2lab::rgb2lab, srgb2rgb::srgb2rgb};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts a sRGB color to Lab\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn srgb2lab(srgb: vec3f) -> vec3f { return rgb2lab(srgb2rgb(srgb));}\n","lygia::color::space::srgb2lch":"import package::color::space::{rgb2lch::rgb2lch, srgb2rgb::srgb2rgb};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts a sRGB color to LCH\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn srgb2lch(srgb: vec3f) -> vec3f { return rgb2lch(srgb2rgb(srgb)); }\n","lygia::color::space::srgb2luma":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Gets the luminosity from sRGB. Based on from Rec601 luma (see https://en.wikipedia.org/wiki/Grayscale)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn srgb2luma(srgb : vec3f) -> f32 { return dot(srgb, vec3f(0.299, 0.587, 0.114)); }\n","lygia::color::space::srgb2oklab":"import package::color::space::srgb2rgb::srgb2rgb;\nimport package::color::space::rgb2oklab::rgb2oklab;\n\n/*\ncontributors: Bjorn Ottosson (@bjornornorn)\ndescription: 'sRGB to OKLab https://bottosson.github.io/posts/oklab/'\nlicense: \n    - MIT License (MIT) Copyright (c) 2020 BjÃ¶rn Ottosson\n*/\n\nfn srgb2oklab(srgb: vec3f) -> vec3f { return rgb2oklab( srgb2rgb(srgb) ); }\n","lygia::color::space::srgb2rgb":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: sRGB to linear RGB conversion.\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn srgb2rgb_mono(channel: f32) -> f32 {\n    if (channel < 0.04045) {\n        return channel * 0.0773993808;\n    }\n    else {\n        return pow((channel + 0.055) * 0.947867298578199, 2.4);\n    }\n}\n\nfn srgb2rgb(srgb:vec3f) -> vec3f {\n    return vec3f(\n            srgb2rgb_mono(srgb.r + 0.00000001),\n            srgb2rgb_mono(srgb.g + 0.00000001),\n            srgb2rgb_mono(srgb.b + 0.00000001)\n        );\n}\n","lygia::color::space::srgb2xyz":"import package::color::space::{rgb2xyz::rgb2xyz, srgb2rgb::srgb2rgb};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts a sRGB color to XYZ\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn srgb2xyz(srgb: vec3f) -> vec3f { return rgb2xyz(srgb2rgb(srgb)); }\n","lygia::color::space::xyY2rgb":"import package::color::space::{xyz2rgb::xyz2rgb, xyY2xyz::xyY2xyz};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts from xyY to linear RGB\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn xyY2rgb(xyY: vec3f) -> vec3f { return xyz2rgb(xyY2xyz(xyY)); }\n","lygia::color::space::xyY2srgb":"import package::color::space::{xyz2srgb::xyz2srgb, xyY2xyz::xyY2xyz};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts from xyY to sRGB\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn xyY2srgb(xyY: vec3f) -> vec3f { return xyz2srgb(xyY2xyz(xyY)); }\n","lygia::color::space::xyY2xyz":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts from xyY to XYZ\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn xyY2xyz(xyY: vec3f) -> vec3f {\n    let Y = xyY.z;\n    let f = 1.0/xyY.y;\n    let x = Y * xyY.x * f;\n    let z = Y * (1.0 - xyY.x - xyY.y) * f;\n    return vec3f(x, Y, z);\n}\n","lygia::color::space::xyz2lab":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts a XYZ color to Lab color space.\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn xyz2lab(c: vec3f) -> vec3f {\n    let n = c / vec3f(95.047, 100.0, 108.883);\n    let c0 = pow(n, vec3f(1.0 / 3.0));\n    let c1 = (7.787 * n) + (16.0 / 116.0);\n    let v = mix(c0, c1, step(n, vec3f(0.008856)));\n    return vec3f( (116.0 * v.y) - 16.0,\n                   500.0 * (v.x - v.y),\n                   200.0 * (v.y - v.z) );\n}\n","lygia::color::space::xyz2rgb":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: 'Converts a XYZ color to linear RGB. From http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html'\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nconst XYZ2RGB = mat3x3<f32>( vec3f( 3.2404542, -0.9692660,  0.0556434),\n                             vec3f(-1.5371385,  1.8760108, -0.2040259),\n                             vec3f(-0.4985314,  0.0415560,  1.0572252) );\n\nfn xyz2rgb(xyz: vec3f) -> vec3f { return XYZ2RGB * (xyz * 0.01); }\n","lygia::color::space::xyz2srgb":"import package::color::space::{xyz2rgb::xyz2rgb, rgb2srgb::rgb2srgb};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: 'Converts a XYZ color to sRGB. From http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html'\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn xyz2srgb(xyz: vec3f) -> vec3f { return rgb2srgb(xyz2rgb(xyz)); }\n","lygia::color::space::xyz2xyY":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Converts from XYZ to xyY space (Y is the luminance)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn xyz2xyY(xyz: vec3f) -> vec3f {\n    let Y = xyz.y;\n    let f = 1.0 / (xyz.x + xyz.y + xyz.z);\n    let x = xyz.x * f;\n    let y = xyz.y * f;\n    return vec3f(x, y, Y);\n}\n","lygia::color::space::yiq2rgb":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: \"Converts a color in YIQ to linear RGB color. \\nFrom https://en.wikipedia.org/wiki/YIQ\\n\"\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nconst YIQ2RGB: mat3x3<f32>  = mat3x3<f32>( \n    vec3f(1.0,  0.9469,  0.6235), \n    vec3f(1.0, -0.2747, -0.6357), \n    vec3f(1.0, -1.1085,  1.7020) );\n\nfn yiq2rgb(yiq : vec3f) -> vec3f { return YIQ2RGB * yiq; }\n","lygia::color::space::yuv2rgb":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Pass a color in YUB and get RGB color\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n// #ifdef YUV_SDTV\n// const YUV2RGB = mat3x3<f32>(\n//     vec3f(1.0,       1.0,      1.0),\n//     vec3f(0.0,      -0.39465,  2.03211),\n//     vec3f(1.13983,  -0.58060,  0.0)\n// );\n// #else\nconst YUV2RGB = mat3x3<f32>(\n    vec3f(1.0,       1.0,      1.0),\n    vec3f(0.0,      -0.21482,  2.12798),\n    vec3f(1.28033,  -0.38059,  0.0)\n);\n// #endif\nfn yuv2rgb(yuv: vec3f) -> vec3f { return YUV2RGB * yuv; }\n","lygia::color::tonemap::aces":"/*\ncontributors: Narkowicz 2015\ndescription: ACES Filmic Tone Mapping Curve. https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nuse: <vec3|vec4> tonemapACES(<vec3|vec4> x)\n*/\n\nconst aces_a = 2.51;\nconst aces_b = 0.03;\nconst aces_c = 2.43;\nconst aces_d = 0.59;\nconst aces_e = 0.14;\n\nfn tonemapACES3(v : vec3f) -> vec3f {\n    return saturate((v * (aces_a * v + aces_b)) / (v * (aces_c * v + aces_d) + aces_e));\n}\n\nfn tonemapACES4(v : vec4f) -> vec4f {\n    return vec4(tonemapACES3(v.rgb), v.a);\n}\n","lygia::color::tonemap::filmic":"/*\ncontributors: [Jim Hejl, Richard Burgess-Dawson ]\ndescription: Haarm-Peter Duikers curve from John Hables presentation \"Uncharted 2 HDR Lighting\", Page 140, http://www.gdcvault.com/play/1012459/Uncharted_2__HDR_Lighting\nuse: <vec3|vec4> tonemapFilmic(<vec3|vec4> x)\n*/\n\nfn tonemapFilmic3(input_v : vec3f) -> vec3f {\n    var v = input_v;\n    v = max(vec3(0.0), v - 0.004);                                       \n    v = (v * (6.2 * v + 0.5)) / (v * (6.2 * v + 1.7) + 0.06);\n    return v;\n}\n\nfn tonemapFilmic4(x : vec4f) -> vec4f {\n    return vec4(tonemapFilmic3(x.rgb), x.a);\n}\n","lygia::color::tonemap::uncharted":"/*\ncontributors: nan\ndescription: Uncharted 2 tonemapping operator\nuse: <vec3|vec4> tonemapUncharted(<vec3|vec4> x)\n*/\n\nfn uncharted2Tonemap(x: vec3f) -> vec3f {\n    const A = 0.15;\n    const B = 0.50;\n    const C = 0.10;\n    const D = 0.20;\n    const E = 0.02;\n    const F = 0.30;\n    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\nfn tonemapUncharted3(x: vec3f) -> vec3f {\n    const W = 11.2;\n    const exposureBias = 2.0;\n    let curr = uncharted2Tonemap(exposureBias * x);\n    let whiteScale = 1.0 / uncharted2Tonemap(vec3(W));\n    return curr * whiteScale;\n}\n\nfn tonemapUncharted4(x: vec4f) -> vec4f { return vec4f(tonemapUncharted3(x.rgb), x.a); }\n","lygia::color::tonemap::uncharted2":"/*\nauthor: John Hable\ndescription: Tonemapping function from presentation, uncharted 2 HDR Lighting, Page 142 to 143\nuse: <vec3|vec4> tonemapUncharted2(<vec3|vec4> x)\n*/\n\nfn tonemapUncharted23(v : vec3f) -> vec3f {\n    let A = 0.15;  // 0.22\n    let B = 0.50;  // 0.30\n    let C = 0.10;\n    let D = 0.20;\n    let E = 0.02;  // 0.01\n    let F = 0.30;\n    let W = 11.2;\n\n    var x = vec4(v, W);\n    x = ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n    return x.xyz / x.w;\n}\n\nfn tonemapUncharted24(x : vec4f) -> vec4f { return vec4(tonemapUncharted23(x.rgb), x.a); }\n","lygia::color::vibrance":"import package::color::space::rgb2luma::rgb2luma;\n\n/*\ncontributors: Christian Cann Schuldt Jensen ~ CeeJay.dk\ndescription: |\n    Vibrance is a smart-tool which cleverly increases the intensity of the more muted colors and leaves the already well-saturated colors alone. Prevents skin tones from becoming overly saturated and unnatural.\n    vibrance from https://github.com/CeeJayDK/SweetFX/blob/master/Shaders/Vibrance.fx\nuse: <vec3|vec4> vibrance(<vec3|vec4> color, <float> v)\nlicense: MIT License (MIT) Copyright (c) 2014 CeeJayDK\n*/\n\nfn vibrance3(color : vec3f, v : f32) -> vec3f {\n    let max_color = max(color.r, max(color.g, color.b));\n    let min_color = min(color.r, min(color.g, color.b));\n    let sat = max_color - min_color;\n    return mix(vec3f(rgb2luma(color)), color, 1.0 + (v * 1.0 - (sign(v) * sat)));\n}\n\nfn vibrance4(color : vec4f, v : f32) -> vec4f { return vec4(vibrance3(color.rgb, v), color.a); }\n","lygia::color::whiteBalance":"/*\ncontributors:\n    - Brad Larson\n    - Ben Cochran\n    - Hugues Lismonde\n    - Keitaroh Kobayashi\n    - Alaric Cole\n    - Matthew Clark\n    - Jacob Gundersen\n    - Chris Williams\n    - Patricio Gonzalez Vivo\ndescription: \"Adjust temperature and tint. \\nOn mobile does a cheaper algo using Brad\\\n    \\ Larson https://github.com/BradLarson/GPUImage/blob/master/framework/Source/GPUImageWhiteBalanceFilter.m\\\n    \\ \\nOn non mobile deas a more accurate adjustment using https://docs.unity3d.com/Packages/com.unity.shadergraph@6.9/manual/White-Balance-Node.html\\n\"\nuse: <vec3|vec4> whiteBalance(<vec3|vec4> rgb, <float> temperature, <float> tint))\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn whiteBalance3(rgb : vec3f, temp : f32, tint : f32) -> vec3f {\n    // Get the CIE xy chromaticity of the reference white point.\n    // Note: 0.31271 = x value on the D65 white point\n\n    var x : f32;\n    if (temp < 0.0) {\n        x = 0.31271 - temp * (0.1);\n    } else {\n        x = 0.31271 - temp * (0.05);\n    }\n\n    let standardIlluminantY = 2.87 * x - 3.0 * x * x - 0.27509507;\n    let y = standardIlluminantY + tint * 0.05;\n\n    // CIExyToLMS\n    let Y = 1.0;\n    let X = Y * x / y;\n    let Z = Y * (1.0 - x - y) / y;\n    let L = 0.7328 * X + 0.4296 * Y - 0.1624 * Z;\n    let M = -0.7036 * X + 1.6975 * Y + 0.0061 * Z;\n    let S = 0.0030 * X + 0.0136 * Y + 0.9834 * Z;\n\n    // Calculate the coefficients in the LMS space.\n    let w = vec3(0.949237, 1.03542, 1.08728);  // D65 white point\n    let balance = w / vec3(L, M, S);\n\n    // TODO: use our own rgb to lms to rgb\n    let lin2lms_mat = mat3x3(3.90405e-1, 5.49941e-1, 8.92632e-3, 7.08416e-2, 9.63172e-1, 1.35775e-3, 2.31082e-2,\n                             1.28021e-1, 9.36245e-1);\n\n    let lms2lin_mat = mat3x3(2.85847e+0, -1.62879e+0, -2.48910e-2, -2.10182e-1, 1.15820e+0, 3.24281e-4, -4.18120e-2,\n                             -1.18169e-1, 1.06867e+0);\n\n    var lms = lin2lms_mat * rgb;\n    lms *= balance;\n    return lms2lin_mat * lms;\n}\n\nfn whiteBalance4(color : vec4f, temp : f32, tint : f32) -> vec4f {\n    return vec4(whiteBalance3(color.rgb, temp, tint), color.a);\n}\n","lygia::draw::stroke":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Fill a stroke in a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: stroke(<float> sdf, <float> size, <float> width [, <float> edge])\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn stroke(x: f32, size: f32, w: f32, edge: f32) -> f32 {\n    return saturate(smoothstep(size - edge, size + edge, x + w * 0.5) - smoothstep(size - edge, size + edge, x - w * 0.5));\n}","lygia::filter::edge::prewitt":"/*\ncontributors: Brad Larson\ndescription: Adapted version of Prewitt edge detection from https://github.com/BradLarson/GPUImage2\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\n    - EDGEPREWITT_TYPE: Return type, defaults to float\n    - EDGEPREWITT_SAMPLER_FNC: Function used to sample the input texture, defaults to texture2D(tex,TEX, UV).r\nexamples:\n    - /shaders/filter_edge2D.frag\n\n*/\n\nfn edgePrewitt(tex: texture_2d<f32>, samp: sampler, uv: vec2f, offset: vec2f) -> vec3f {\n    let top_left = textureSample(tex, samp, uv + vec2f(-offset.x, offset.y)).xyz;\n    let left = textureSample(tex, samp, uv + vec2f(-offset.x, 0.)).xyz;\n    let bottom_left = textureSample(tex, samp, uv + vec2f(-offset.x, -offset.y)).xyz;\n    let top = textureSample(tex, samp, uv + vec2f(0., offset.y)).xyz;\n    let bottom = textureSample(tex, samp, uv + vec2f(0., -offset.y)).xyz;\n    let top_right = textureSample(tex, samp, uv + offset).xyz;\n    let right = textureSample(tex, samp, uv + vec2f(offset.x, 0.)).xyz;\n    let bottom_right = textureSample(tex, samp, uv + vec2f(offset.x, -offset.y)).xyz;\n    let x = -top_left - top - top_right + bottom_left + bottom + bottom_right;\n    let y = -bottom_left - left - top_left + bottom_right + right + top_right;\n    return sqrt((x * x) + (y * y));\n}\n","lygia::filter::sharpen::adaptive":"/*\ncontributors: bacondither\ndescription: Adaptive sharpening. For strength values between 0.3 <-> 2.0 are a reasonable range\nuse: sharpen(<SAMPLER_TYPE> texture, <vec2> st, <vec2> renderSize [, float streanght])\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\n    - SHARPENADAPTIVE_TYPE: defaults to vec3\n    - SHARPENDADAPTIVE_SAMPLER_FNC(TEX, UV): defaults to texture2D(TEX, UV).rgb\n    - SHARPENADAPTIVE_ANIME: only darken edges. Defaults to false\nexamples:\n    - /shaders/filter_sharpen2D.frag\n*/\n\nfn sharpenContrastAdaptive(myTexture: texture_2d<f32>,\n                           mySampler: sampler,\n                           st: vec2f,\n                           pixel: vec2f,\n                           strength: f32) -> vec3f {\n    let peak = -1.0 / mix(8.0, 5.0, saturate(strength));\n\n    // fetch a 3x3 neighborhood around the pixel 'e',\n    //  a b c\n    //  d(e)f\n    //  g h i\n    let a = textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(-1., -1.) * pixel).rgb;\n    let b = textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(0., -1.) * pixel).rgb;\n    let c = textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(1., -1.) * pixel).rgb;\n    let d = textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(-1., 0.) * pixel).rgb;\n    let e = textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(0., 0.) * pixel).rgb;\n    let f = textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(1., 0.) * pixel).rgb;\n    let g = textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(-1., 1.) * pixel).rgb;\n    let h = textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(0., 1.) * pixel).rgb;\n    let i = textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(1., 1.) * pixel).rgb;\n\n    // Soft min and max.\n    //  a b c             b\n    //  d e f * 0.5  +  d e f * 0.5\n    //  g h i             h\n    // These are 2.0x bigger (factored out the extra multiply).\n    var mnRGB = min(min(min(d, e), min(f, b)), h);\n    let mnRGB2 = min(mnRGB, min(min(a, c), min(g, i)));\n    mnRGB += mnRGB2;\n\n    var mxRGB = max(max(max(d, e), max(f, b)), h);\n    let mxRGB2 = max(mxRGB, max(max(a, c), max(g, i)));\n    mxRGB += mxRGB2;\n\n    // Smooth minimum distance to signal limit divided by smooth max.\n    let ampRGB = saturate(min(mnRGB, 2.0 - mxRGB) / mxRGB);\n\n    // Shaping amount of sharpening.\n    let wRGB = sqrt(ampRGB) * peak;\n\n    // Filter shape.\n    //  0 w 0\n    //  w 1 w\n    //  0 w 0\n    let weightRGB = 1.0 + 4.0 * wRGB;\n    let window = (b + d) + (f + h);\n\n    return saturate((window * wRGB + e) / weightRGB);\n}\n\nconst SHARPENADAPTIVE_ANIME = false;  // Only darken edges\n\n// Soft limit, modified tanh approx\nfn SHARPENADAPTIVE_SOFT_LIM(v : f32, s : f32) -> f32 {\n    return (saturate(abs(v / s) * (27.0 + pow(v / s, 2.0)) / (27.0 + 9.0 * pow(v / s, 2.0))) * s);\n}\n\n// Weighted power mean\nfn SHARPENADAPTIVE_WPMEAN(a : f32, b : f32, w : f32) -> f32 {\n    return (pow(w * pow(abs(a), 0.5) + abs(1.0 - w) * pow(abs(b), 0.5), 2.0));\n}\n\n// Get destination pixel values\nfn SHARPENADAPTIVE_DXDY(val : vec4f) -> f32 {\n    return (length(fwidth(val)));  // edgemul = 2.2\n}\n\n// #define SHARPENADAPTIVE_CTRL(RGB)   ( dot(RGB*RGB, vec3(0.212655, 0.715158, 0.072187)) )\nfn SHARPENADAPTIVE_CTRL(RGB : vec4f) -> f32 { return sharpendAdaptiveControl4(RGB); }\n\nfn sharpendAdaptiveControl3(rgb : vec3f) -> f32 { return dot(rgb * rgb, vec3(0.212655, 0.715158, 0.072187)); }\nfn sharpendAdaptiveControl4(rgba : vec4f) -> f32 { return dot(rgba * rgba, vec4(0.212655, 0.715158, 0.072187, 0.0)); }\n\n//-------------------------------------------------------------------------------------------------\n// Defined values under this row are \"optimal\" DO NOT CHANGE IF YOU DO NOT KNOW WHAT YOU ARE DOING!\nconst curveslope = 0.5;  // Sharpening curve slope, high edge values\n\nconst L_overshoot = 0.003;  // Max light overshoot before compression [>0.001]\nconst L_compr_low = 0.167;  // Light compression, default (0.167=~6x)\n\nconst D_overshoot = 0.009;  // Max dark overshoot before compression [>0.001]\nconst D_compr_low = 0.250;  // Dark compression, default (0.250=4x)\n\nconst scale_lim = 0.1;   // Abs max change before compression [>0.01]\nconst scale_cs = 0.056;  // Compression slope above scale_lim\n\n// Precalculated default squared kernel weights\nconst w1 = vec3(0.5, 1.0, 1.41421356237);            // 0.25, 1.0, 2.0\nconst w2 = vec3(0.86602540378, 1.0, 0.54772255751);  // 0.75, 1.0, 0.3\n\nfn sharpenAdaptive(myTexture: texture_2d<f32>,\n                   mySampler: sampler,\n                   st: vec2f,\n                   pixel: vec2f,\n                   strength: f32) -> vec4f {\n    // [                c22               ]\n    // [           c24, c9,  c23          ]\n    // [      c21, c1,  c2,  c3, c18      ]\n    // [ c19, c10, c4,  c0,  c5, c11, c16 ]\n    // [      c20, c6,  c7,  c8, c17      ]\n    // [           c15, c12, c14          ]\n    // [                c13               ]\n    let c = array<vec4f, 25>(textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(0.0, 0.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(-1., -1.) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(0.0, -1.) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(1.0, -1.) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(-1., 1.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(1.0, 0.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(-1., 1.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(0.0, 1.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(1.0, 1.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(0.0, -2.) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(-2., 0.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(2., 0.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(0., 2.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(0., 3.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(1., 2.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(-1., 2.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(3., 0.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(2., 1.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(2., -1.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(-3., 0.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(-2., 1.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(-2., -1.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(0., -3.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(1., -2.0) * pixel),\n                             textureSampleBaseClampToEdge(myTexture, mySampler, st + vec2(-1., -2.0) * pixel));\n\n    let e = array<f32, 13>(SHARPENADAPTIVE_DXDY(c[0]), SHARPENADAPTIVE_DXDY(c[1]), SHARPENADAPTIVE_DXDY(c[2]),\n                           SHARPENADAPTIVE_DXDY(c[3]), SHARPENADAPTIVE_DXDY(c[4]), SHARPENADAPTIVE_DXDY(c[5]),\n                           SHARPENADAPTIVE_DXDY(c[6]), SHARPENADAPTIVE_DXDY(c[7]), SHARPENADAPTIVE_DXDY(c[8]),\n                           SHARPENADAPTIVE_DXDY(c[9]), SHARPENADAPTIVE_DXDY(c[10]), SHARPENADAPTIVE_DXDY(c[11]),\n                           SHARPENADAPTIVE_DXDY(c[12]));\n\n    // Blur, gauss 3x3\n    let blur = (2.0 * (c[2] + c[4] + c[5] + c[7]) + (c[1] + c[3] + c[6] + c[8]) + 4.0 * c[0]) / 16.0;\n\n    // Contrast compression, center = 0.5, scaled to 1/3\n    let c_comp = saturate(0.266666681 + 0.9 * exp2(dot(blur, vec4f(-7.4 / 3.0))));\n\n    // Edge detection\n    // Relative matrix weights\n    // [          1          ]\n    // [      4,  5,  4      ]\n    // [  1,  5,  6,  5,  1  ]\n    // [      4,  5,  4      ]\n    // [          1          ]\n    /*\n     *fn SHARPENADAPTIVE_DIFF(pix : f32) -> f32 {\n     *    return (abs(blur - c[pix]));\n     *}\n     */\n    let edge = length(1.38 * (abs(blur - c[0])) +\n                      1.15 * ((abs(blur - c[2])) + (abs(blur - c[4])) + (abs(blur - c[5])) + (abs(blur - c[7]))) +\n                      0.92 * ((abs(blur - c[1])) + (abs(blur - c[3])) + (abs(blur - c[6])) + (abs(blur - c[8]))) +\n                      0.23 * ((abs(blur - c[9])) + (abs(blur - c[10])) + (abs(blur - c[11])) + (abs(blur - c[12])))) *\n               c_comp;\n\n    let cs = vec2(L_compr_low, D_compr_low);\n\n    // RGB to luma\n    var luma = array<f32, 25>(SHARPENADAPTIVE_CTRL(c[0]), SHARPENADAPTIVE_CTRL(c[1]), SHARPENADAPTIVE_CTRL(c[2]),\n                              SHARPENADAPTIVE_CTRL(c[3]), SHARPENADAPTIVE_CTRL(c[4]), SHARPENADAPTIVE_CTRL(c[5]),\n                              SHARPENADAPTIVE_CTRL(c[6]), SHARPENADAPTIVE_CTRL(c[7]), SHARPENADAPTIVE_CTRL(c[8]),\n                              SHARPENADAPTIVE_CTRL(c[9]), SHARPENADAPTIVE_CTRL(c[10]), SHARPENADAPTIVE_CTRL(c[11]),\n                              SHARPENADAPTIVE_CTRL(c[12]), SHARPENADAPTIVE_CTRL(c[13]), SHARPENADAPTIVE_CTRL(c[14]),\n                              SHARPENADAPTIVE_CTRL(c[15]), SHARPENADAPTIVE_CTRL(c[16]), SHARPENADAPTIVE_CTRL(c[17]),\n                              SHARPENADAPTIVE_CTRL(c[18]), SHARPENADAPTIVE_CTRL(c[19]), SHARPENADAPTIVE_CTRL(c[20]),\n                              SHARPENADAPTIVE_CTRL(c[21]), SHARPENADAPTIVE_CTRL(c[22]), SHARPENADAPTIVE_CTRL(c[23]),\n                              SHARPENADAPTIVE_CTRL(c[24]));\n\n    let c0_Y = sqrt(luma[0]);\n\n    // Transition to a concave kernel if the center edge val is above thr\n    let dW = pow(mix(w1, w2, saturate(2.4 * edge - 0.82)), vec3(2.0));\n\n    // Use lower weights for pixels in a more active area relative to center pixel area\n    // This results in narrower and less visible overshoots around sharp edges\n    let modif_e0 = 3.0 * e[0] + 0.0090909;\n\n    var weights =\n        array<f32, 12>(min(modif_e0 / e[1], dW.y), dW.x, min(modif_e0 / e[3], dW.y), dW.x, dW.x,\n                       min(modif_e0 / e[6], dW.y), dW.x, min(modif_e0 / e[8], dW.y), min(modif_e0 / e[9], dW.z),\n                       min(modif_e0 / e[10], dW.z), min(modif_e0 / e[11], dW.z), min(modif_e0 / e[12], dW.z));\n\n    weights[0] = (max(max((weights[8] + weights[9]) / 4.0, weights[0]), 0.25) + weights[0]) / 2.0;\n    weights[2] = (max(max((weights[8] + weights[10]) / 4.0, weights[2]), 0.25) + weights[2]) / 2.0;\n    weights[5] = (max(max((weights[9] + weights[11]) / 4.0, weights[5]), 0.25) + weights[5]) / 2.0;\n    weights[7] = (max(max((weights[10] + weights[11]) / 4.0, weights[7]), 0.25) + weights[7]) / 2.0;\n\n    // Calculate the negative part of the laplace kernel and the low threshold weight\n    var lowthrsum = 0.0;\n    var weightsum = 0.0;\n    var neg_laplace = 0.0;\n\n    for (var pix = 0; pix < 12; pix += 1) {\n        let lowthr = clamp((29.04 * e[pix + 1] - 0.221), 0.01, 1.0);\n\n        neg_laplace += luma[pix + 1] * weights[pix] * lowthr;\n        weightsum += weights[pix] * lowthr;\n        lowthrsum += lowthr / 12.0;\n    }\n\n    neg_laplace = inverseSqrt(weightsum / neg_laplace);\n\n    // Compute sharpening magnitude function\n    let sharpen_val = strength / (strength * curveslope * pow(edge, 3.5) + 0.625);\n\n    // Calculate sharpening diff and scale\n    var sharpdiff = (c0_Y - neg_laplace) * (lowthrsum * sharpen_val + 0.01);\n\n    // Calculate local near min & max, partial sort\n    var temp = 0.0;\n\n    for (var i1 = 0; i1 < 24; i1 += 2) {\n        temp = luma[i1];\n        luma[i1] = min(luma[i1], luma[i1 + 1]);\n        luma[i1 + 1] = max(temp, luma[i1 + 1]);\n    }\n\n    for (var i2 = 24; i2 > 0; i2 -= 2) {\n        temp = luma[0];\n        luma[0] = min(luma[0], luma[i2]);\n        luma[i2] = max(temp, luma[i2]);\n\n        temp = luma[24];\n        luma[24] = max(luma[24], luma[i2 - 1]);\n        luma[i2 - 1] = min(temp, luma[i2 - 1]);\n    }\n\n    for (var i1 = 1; i1 < 24 - 1; i1 += 2) {\n        temp = luma[i1];\n        luma[i1] = min(luma[i1], luma[i1 + 1]);\n        luma[i1 + 1] = max(temp, luma[i1 + 1]);\n    }\n\n    for (var i2 = 24 - 1; i2 > 1; i2 -= 2) {\n        temp = luma[1];\n        luma[1] = min(luma[1], luma[i2]);\n        luma[i2] = max(temp, luma[i2]);\n\n        temp = luma[24 - 1];\n        luma[24 - 1] = max(luma[24 - 1], luma[i2 - 1]);\n        luma[i2 - 1] = min(temp, luma[i2 - 1]);\n    }\n\n    let nmax = (max(sqrt(luma[23]), c0_Y) * 2.0 + sqrt(luma[24])) / 3.0;\n    let nmin = (min(sqrt(luma[1]), c0_Y) * 2.0 + sqrt(luma[0])) / 3.0;\n\n    let min_dist = min(abs(nmax - c0_Y), abs(c0_Y - nmin));\n    var pos_scale = min_dist + L_overshoot;\n    var neg_scale = min_dist + D_overshoot;\n\n    pos_scale = min(pos_scale, scale_lim * (1.0 - scale_cs) + pos_scale * scale_cs);\n    neg_scale = min(neg_scale, scale_lim * (1.0 - scale_cs) + neg_scale * scale_cs);\n\n    // Soft limited anti-ringing with tanh, SHARPENADAPTIVE_WPMEAN to control compression slope\n\n    if (SHARPENADAPTIVE_ANIME) {\n        sharpdiff = 0;\n    } else {\n        sharpdiff =\n            SHARPENADAPTIVE_WPMEAN(max(sharpdiff, 0.0), SHARPENADAPTIVE_SOFT_LIM(max(sharpdiff, 0.0), pos_scale), cs.x);\n    }\n\n    sharpdiff -=\n        SHARPENADAPTIVE_WPMEAN(min(sharpdiff, 0.0), SHARPENADAPTIVE_SOFT_LIM(min(sharpdiff, 0.0), neg_scale), cs.y);\n\n    let sharpdiff_lim = saturate(c0_Y + sharpdiff) - c0_Y;\n    let satmul = (c0_Y + max(sharpdiff_lim * 0.9, sharpdiff_lim) * 1.03 + 0.03) / (c0_Y + 0.03);\n    return c0_Y + (sharpdiff_lim * 3.0 + sharpdiff) / 4.0 + (c[0] - c0_Y) * satmul;\n}\n","lygia::filter::sharpen::fast":"\n/*\ncontributors: Johan Ismael\ndescription: Sharpening convolutional operation\nuse: sharpen(<SAMPLER_TYPE> texture, <vec2> st, <vec2> pixel)\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\n    - SHARPENFAST_KERNELSIZE: Defaults 2\n    - SHARPENFAST_TYPE: defaults to vec3\n    - SHARPENFAST_SAMPLER_FNC(TEX, UV): defaults to texture2D(tex, TEX, UV).rgb\n*/\n\nconst SHARPENFAST_KERNELSIZE = 2;\n\nfn sharpenFast(myTexture: texture_2d<f32>,\n               mySampler: sampler,\n               coords: vec2f,\n               pixel: vec2f,\n               strength: f32) -> vec4f {\n    var sum = vec4f(0.);\n    for (var i = 0; i < SHARPENFAST_KERNELSIZE; i++) {\n        var f_size = f32(i) + 1.;\n        f_size *= strength;\n        sum += -1. * textureSampleBaseClampToEdge(myTexture, mySampler, coords + vec2(-1., 0.) * pixel * f_size);\n        sum += -1. * textureSampleBaseClampToEdge(myTexture, mySampler, coords + vec2(0., -1.) * pixel * f_size);\n        sum += 5. * textureSampleBaseClampToEdge(myTexture, mySampler, coords + vec2(0., 0.) * pixel * f_size);\n        sum += -1. * textureSampleBaseClampToEdge(myTexture, mySampler, coords + vec2(0., 1.) * pixel * f_size);\n        sum += -1. * textureSampleBaseClampToEdge(myTexture, mySampler, coords + vec2(1., 0.) * pixel * f_size);\n    }\n    return sum / f32(SHARPENFAST_KERNELSIZE);\n}\n","lygia::generative::cnoise":"import package::math::mod289::{mod289_3, mod289_4};\nimport package::math::permute::permute4; \nimport package::math::taylorInvSqrt4::taylorInvSqrt4;\nimport package::math::quintic::{quintic2, quintic3, quintic4};\n\n/*\ncontributors: [Stefan Gustavson, Ian McEwan]\ndescription: Classic Perlin Noise https://github.com/stegu/webgl-noise\nuse: cnoise2/3/4(<vec2f|vec3f|vec4f> pos)\nlicense: |\n    Copyright 2021-2023 by Stefan Gustavson and Ian McEwan.\n    Published under the terms of the MIT license:\n    https://opensource.org/license/mit/\n*/\n\nfn cnoise2(P: vec2f) -> f32 {\n    var Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    let Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289_4(Pi); // To avoid truncation effects in permutation\n    let ix = Pi.xzxz;\n    let iy = Pi.yyww;\n    let fx = Pf.xzxz;\n    let fy = Pf.yyww;\n\n    let i = permute4(permute4(ix) + iy);\n\n    var gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    let gy = abs(gx) - 0.5 ;\n    let tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    var g00 = vec2(gx.x,gy.x);\n    var g10 = vec2(gx.y,gy.y);\n    var g01 = vec2(gx.z,gy.z);\n    var g11 = vec2(gx.w,gy.w);\n\n    let norm = taylorInvSqrt4(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 = g00 * norm.x;\n    g01 = g01 * norm.y;\n    g10 = g10 * norm.z;\n    g11 = g11 * norm.w;\n\n    let n00 = dot(g00, vec2(fx.x, fy.x));\n    let n10 = dot(g10, vec2(fx.y, fy.y));\n    let n01 = dot(g01, vec2(fx.z, fy.z));\n    let n11 = dot(g11, vec2(fx.w, fy.w));\n\n    let fade_xy = quintic2(Pf.xy);\n    let n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    let n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nfn cnoise3(P: vec3f) -> f32 {\n    var Pi0 = floor(P); // Integer part for indexing\n    var Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289_3(Pi0);\n    Pi1 = mod289_3(Pi1);\n    let Pf0 = fract(P); // Fractional part for interpolation\n    let Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    let ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    let iy = vec4(Pi0.yy, Pi1.yy);\n    let iz0 = Pi0.zzzz;\n    let iz1 = Pi1.zzzz;\n\n    let ixy = permute4(permute4(ix) + iy);\n    let ixy0 = permute4(ixy + iz0);\n    let ixy1 = permute4(ixy + iz1);\n\n    var gx0 = ixy0 * (1.0 / 7.0);\n    var gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    let gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    let sz0 = step(gz0, vec4(0.0));\n    gx0 = gx0 - (sz0 * (step(vec4(0.0), gx0) - 0.5));\n    gy0 = gy0 - (sz0 * (step(vec4(0.0), gy0) - 0.5));\n\n    var gx1 = ixy1 * (1.0 / 7.0);\n    var gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    let gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    let sz1 = step(gz1, vec4(0.0));\n    gx1 = gx1 - (sz1 * (step(vec4(0.0), gx1) - 0.5));\n    gy1 = gy1 - (sz1 * (step(vec4(0.0), gy1) - 0.5));\n\n    var g000 = vec3(gx0.x,gy0.x,gz0.x);\n    var g100 = vec3(gx0.y,gy0.y,gz0.y);\n    var g010 = vec3(gx0.z,gy0.z,gz0.z);\n    var g110 = vec3(gx0.w,gy0.w,gz0.w);\n    var g001 = vec3(gx1.x,gy1.x,gz1.x);\n    var g101 = vec3(gx1.y,gy1.y,gz1.y);\n    var g011 = vec3(gx1.z,gy1.z,gz1.z);\n    var g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    let norm0 = taylorInvSqrt4(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 = g000 * norm0.x;\n    g010 = g010 * norm0.y;\n    g100 = g100 * norm0.z;\n    g110 = g110 * norm0.w;\n    let norm1 = taylorInvSqrt4(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 = g001 * norm1.x;\n    g011 = g011 * norm1.y;\n    g101 = g101 * norm1.z;\n    g111 = g111 * norm1.w;\n\n    let n000 = dot(g000, Pf0);\n    let n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    let n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    let n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    let n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    let n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    let n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    let n111 = dot(g111, Pf1);\n\n    let fade_xyz = quintic3(Pf0);\n    let n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    let n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    let n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\nfn cnoise4(P: vec4f) -> f32 {\n    var Pi0 = floor(P); // Integer part for indexing\n    var Pi1 = Pi0 + 1.0; // Integer part + 1\n    Pi0 = mod289_4(Pi0);\n    Pi1 = mod289_4(Pi1);\n    let Pf0 = fract(P); // Fractional part for interpolation\n    let Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    let ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    let iy = vec4(Pi0.yy, Pi1.yy);\n    let iz0 = vec4(Pi0.zzzz);\n    let iz1 = vec4(Pi1.zzzz);\n    let iw0 = vec4(Pi0.wwww);\n    let iw1 = vec4(Pi1.wwww);\n\n    let ixy = permute4(permute4(ix) + iy);\n    let ixy0 = permute4(ixy + iz0);\n    let ixy1 = permute4(ixy + iz1);\n    let ixy00 = permute4(ixy0 + iw0);\n    let ixy01 = permute4(ixy0 + iw1);\n    let ixy10 = permute4(ixy1 + iw0);\n    let ixy11 = permute4(ixy1 + iw1);\n\n    var gx00 = ixy00 * (1.0 / 7.0);\n    var gy00 = floor(gx00) * (1.0 / 7.0);\n    var gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    var gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    var sw00 = step(gw00, vec4(0.0));\n    gx00 = gx00 - (sw00 * (step(vec4(0.0), gx00) - 0.5));\n    gy00 = gy00 - (sw00 * (step(vec4(0.0), gy00) - 0.5));\n\n    var gx01 = ixy01 * (1.0 / 7.0);\n    var gy01 = floor(gx01) * (1.0 / 7.0);\n    var gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    var gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    var sw01 = step(gw01, vec4(0.0));\n    gx01 = gx01 - (sw01 * (step(vec4(0.0), gx01) - 0.5));\n    gy01 = gy01 - (sw01 * (step(vec4(0.0), gy01) - 0.5));\n\n    var gx10 = ixy10 * (1.0 / 7.0);\n    var gy10 = floor(gx10) * (1.0 / 7.0);\n    var gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    var gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    var sw10 = step(gw10, vec4(0.0));\n    gx10 = gx10 - (sw10 * (step(vec4(0.0), gx10) - 0.5));\n    gy10 = gy10 - (sw10 * (step(vec4(0.0), gy10) - 0.5));\n\n    var gx11 = ixy11 * (1.0 / 7.0);\n    var gy11 = floor(gx11) * (1.0 / 7.0);\n    var gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    var gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    var sw11 = step(gw11, vec4(0.0));\n    gx11 = gx11 - (sw11 * (step(vec4(0.0), gx11) - 0.5));\n    gy11 = gy11 - (sw11 * (step(vec4(0.0), gy11) - 0.5));\n\n    var g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    var g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    var g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    var g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    var g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    var g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    var g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    var g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    var g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    var g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    var g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    var g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    var g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    var g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    var g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    var g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    let norm00 = taylorInvSqrt4(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 = g0000 * norm00.x;\n    g0100 = g0100 * norm00.y;\n    g1000 = g1000 * norm00.z;\n    g1100 = g1100 * norm00.w;\n\n    let norm01 = taylorInvSqrt4(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 = g0001 * norm01.x;\n    g0101 = g0101 * norm01.y;\n    g1001 = g1001 * norm01.z;\n    g1101 = g1101 * norm01.w;\n\n    let norm10 = taylorInvSqrt4(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 = g0010 * norm10.x;\n    g0110 = g0110 * norm10.y;\n    g1010 = g1010 * norm10.z;\n    g1110 = g1110 * norm10.w;\n\n    let norm11 = taylorInvSqrt4(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 = g0011 * norm11.x;\n    g0111 = g0111 * norm11.y;\n    g1011 = g1011 * norm11.z;\n    g1111 = g1111 * norm11.w;\n\n    let n0000 = dot(g0000, Pf0);\n    let n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    let n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    let n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    let n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    let n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    let n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    let n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    let n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    let n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    let n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    let n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    let n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    let n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    let n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    let n1111 = dot(g1111, Pf1);\n\n    let fade_xyzw = quintic4(Pf0);\n    let n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    let n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    let n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    let n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    let n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n}\n","lygia::generative::noised":"import package::generative::srandom::{srandom22, srandom33};\n\n/*\ncontributors:\n    - Inigo Quilez\ndescription: Returns 2D/3D value noise in the first channel and in the rest the derivatives. For more details read this nice article http://www.iquilezles.org/www/articles/gradientnoise/gradientnoise.htm\nuse:\n    - <vec3f> noised2(<vec2f>)\n    - <vec4f> noised3(<vec3f>)\nexamples:\n    - /shaders/generative_noised.frag\n*/\n\n// return gradient noise (in x) and its derivatives (in yz)\nfn noised2 (p: vec2f) -> vec3f {\n    // grid\n    let i = floor( p );\n    let f = fract( p );\n\n    // quintic interpolation\n    let u = f * f * f * (f * (f * 6. - 15.) + 10.);\n    let du = 30. * f * f * (f * (f - 2.) + 1.);\n\n    let ga = srandom22(i + vec2(0., 0.));\n    let gb = srandom22(i + vec2(1., 0.));\n    let gc = srandom22(i + vec2(0., 1.));\n    let gd = srandom22(i + vec2(1., 1.));\n\n    let va = dot(ga, f - vec2(0., 0.));\n    let vb = dot(gb, f - vec2(1., 0.));\n    let vc = dot(gc, f - vec2(0., 1.));\n    let vd = dot(gd, f - vec2(1., 1.));\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),  // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va) );\n}\n\nfn noised3 (pos: vec3f) -> vec4f {\n    // grid\n    let p = floor(pos);\n    let w = fract(pos);\n\n    // quintic interpolant\n    let u = w * w * w * ( w * (w * 6. - 15.) + 10. );\n    let du = 30.0 * w * w * ( w * (w - 2.) + 1.);\n\n    // gradients\n    let ga = srandom33(p + vec3(0., 0., 0.));\n    let gb = srandom33(p + vec3(1., 0., 0.));\n    let gc = srandom33(p + vec3(0., 1., 0.));\n    let gd = srandom33(p + vec3(1., 1., 0.));\n    let ge = srandom33(p + vec3(0., 0., 1.));\n    let gf = srandom33(p + vec3(1., 0., 1.));\n    let gg = srandom33(p + vec3(0., 1., 1.));\n    let gh = srandom33(p + vec3(1., 1., 1.));\n\n    // projections\n    let va = dot(ga, w - vec3(0., 0., 0.));\n    let vb = dot(gb, w - vec3(1., 0., 0.));\n    let vc = dot(gc, w - vec3(0., 1., 0.));\n    let vd = dot(gd, w - vec3(1., 1., 0.));\n    let ve = dot(ge, w - vec3(0., 0., 1.));\n    let vf = dot(gf, w - vec3(1., 0., 1.));\n    let vg = dot(gg, w - vec3(0., 1., 1.));\n    let vh = dot(gh, w - vec3(1., 1., 1.));\n\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh)) );\n}\n","lygia::generative::pnoise":"import package::math::mod289::{mod289, mod289_3, mod289_4};\nimport package::math::permute::{permute4};\nimport package::math::taylorInvSqrt::{taylorInvSqrt4};\nimport package::math::quintic::{quintic2, quintic3, quintic4};\n\n/*\ncontributors: [Stefan Gustavson, Ian McEwan]\ndescription: Classic Perlin Noise with periodic variant https://github.com/stegu/webgl-noise\nuse: pnoise2/3/4(<vec2f|vec3f|vec4f> pos, <vec2f|vec3f|vec4f> periodic)\nlicense: |\n    Copyright 2021-2023 by Stefan Gustavson and Ian McEwan.\n    Published under the terms of the MIT license:\n    https://opensource.org/license/mit/\n*/\n\nfn pnoise2(P: vec2f, rep: vec2f) -> f32 {\n    var Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    let Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = Pi % rep.xyxy; // To create noise with explicit period\n    Pi = mod289_4(Pi); // To avoid truncation effects in permutation\n    let ix = Pi.xzxz;\n    let iy = Pi.yyww;\n    let fx = Pf.xzxz;\n    let fy = Pf.yyww;\n\n    let i = permute4(permute4(ix) + iy);\n\n    var gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    let gy = abs(gx) - 0.5 ;\n    let tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    var g00 = vec2(gx.x,gy.x);\n    var g10 = vec2(gx.y,gy.y);\n    var g01 = vec2(gx.z,gy.z);\n    var g11 = vec2(gx.w,gy.w);\n\n    let norm = taylorInvSqrt4(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 = g00 * norm.x;\n    g01 = g01 * norm.y;\n    g10 = g10 * norm.z;\n    g11 = g11 * norm.w;\n\n    let n00 = dot(g00, vec2(fx.x, fy.x));\n    let n10 = dot(g10, vec2(fx.y, fy.y));\n    let n01 = dot(g01, vec2(fx.z, fy.z));\n    let n11 = dot(g11, vec2(fx.w, fy.w));\n\n    let fade_xy = quintic2(Pf.xy);\n    let n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    let n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nfn pnoise3(P: vec3f, rep: vec3f)-> f32 {\n    var Pi0 = floor(P) % rep; // Integer part, modulo period\n    var Pi1 = (Pi0 + vec3(1.0)) % rep; // Integer part + 1, mod period\n    Pi0 = mod289_3(Pi0);\n    Pi1 = mod289_3(Pi1);\n    let Pf0 = fract(P); // Fractional part for interpolation\n    let Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    let ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    let iy = vec4(Pi0.yy, Pi1.yy);\n    let iz0 = Pi0.zzzz;\n    let iz1 = Pi1.zzzz;\n\n    let ixy = permute4(permute4(ix) + iy);\n    let ixy0 = permute4(ixy + iz0);\n    let ixy1 = permute4(ixy + iz1);\n\n    var gx0 = ixy0 * (1.0 / 7.0);\n    var gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    var gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    var sz0 = step(gz0, vec4(0.0));\n    gx0 = gx0 - (sz0 * (step(vec4(0.0), gx0) - 0.5));\n    gy0 = gy0 - (sz0 * (step(vec4(0.0), gy0) - 0.5));\n\n    var gx1 = ixy1 * (1.0 / 7.0);\n    var gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    var gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    var sz1 = step(gz1, vec4(0.0));\n    gx1 = gx1 - (sz1 * (step(vec4(0.0), gx1) - 0.5));\n    gy1 = gy1 - (sz1 * (step(vec4(0.0), gy1) - 0.5));\n\n    var g000 = vec3(gx0.x,gy0.x,gz0.x);\n    var g100 = vec3(gx0.y,gy0.y,gz0.y);\n    var g010 = vec3(gx0.z,gy0.z,gz0.z);\n    var g110 = vec3(gx0.w,gy0.w,gz0.w);\n    var g001 = vec3(gx1.x,gy1.x,gz1.x);\n    var g101 = vec3(gx1.y,gy1.y,gz1.y);\n    var g011 = vec3(gx1.z,gy1.z,gz1.z);\n    var g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    var norm0 = taylorInvSqrt4(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 = g000 * norm0.x;\n    g010 = g010 * norm0.y;\n    g100 = g100 * norm0.z;\n    g110 = g110 * norm0.w;\n    var norm1 = taylorInvSqrt4(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 = g001 * norm1.x;\n    g011 = g011 * norm1.y;\n    g101 = g101 * norm1.z;\n    g111 = g111 * norm1.w;\n\n    let n000 = dot(g000, Pf0);\n    let n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    let n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    let n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    let n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    let n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    let n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    let n111 = dot(g111, Pf1);\n\n    let fade_xyz = quintic3(Pf0);\n    let n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    let n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    let n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\n\nfn pnoise4(P: vec4f, rep: vec4f) -> f32 {\n    var Pi0 = floor(P) % rep; // Integer part modulo rep\n    var Pi1 = (Pi0 + 1.0) % rep; // Integer part + 1 mod rep\n    Pi0 = mod289_4(Pi0);\n    Pi1 = mod289_4(Pi1);\n    let Pf0 = fract(P); // Fractional part for interpolation\n    let Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    let ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    let iy = vec4(Pi0.yy, Pi1.yy);\n    let iz0 = vec4(Pi0.zzzz);\n    let iz1 = vec4(Pi1.zzzz);\n    let iw0 = vec4(Pi0.wwww);\n    let iw1 = vec4(Pi1.wwww);\n\n    let ixy = permute4(permute4(ix) + iy);\n    let ixy0 = permute4(ixy + iz0);\n    let ixy1 = permute4(ixy + iz1);\n    let ixy00 = permute4(ixy0 + iw0);\n    let ixy01 = permute4(ixy0 + iw1);\n    let ixy10 = permute4(ixy1 + iw0);\n    let ixy11 = permute4(ixy1 + iw1);\n\n    var gx00 = ixy00 * (1.0 / 7.0);\n    var gy00 = floor(gx00) * (1.0 / 7.0);\n    var gz00 = floor(gy00) * (1.0 / 6.0);\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    var gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    var sw00 = step(gw00, vec4(0.0));\n    gx00 = gx00 - (sw00 * (step(vec4(0.0), gx00) - 0.5));\n    gy00 = gy00 - (sw00 * (step(vec4(0.0), gy00) - 0.5));\n\n    var gx01 = ixy01 * (1.0 / 7.0);\n    var gy01 = floor(gx01) * (1.0 / 7.0);\n    var gz01 = floor(gy01) * (1.0 / 6.0);\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    var gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    var sw01 = step(gw01, vec4(0.0));\n    gx01 = gx01 - (sw01 * (step(vec4(0.0), gx01) - 0.5));\n    gy01 = gy01 - (sw01 * (step(vec4(0.0), gy01) - 0.5));\n\n    var gx10 = ixy10 * (1.0 / 7.0);\n    var gy10 = floor(gx10) * (1.0 / 7.0);\n    var gz10 = floor(gy10) * (1.0 / 6.0);\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    var gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    var sw10 = step(gw10, vec4(0.0));\n    gx10 = gx10 - (sw10 * (step(vec4(0.0), gx10) - 0.5));\n    gy10 = gy10 - (sw10 * (step(vec4(0.0), gy10) - 0.5));\n\n    var gx11 = ixy11 * (1.0 / 7.0);\n    var gy11 = floor(gx11) * (1.0 / 7.0);\n    var gz11 = floor(gy11) * (1.0 / 6.0);\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    var gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    var sw11 = step(gw11, vec4(0.0));\n    gx11 = gx11 - (sw11 * (step(vec4(0.0), gx11) - 0.5));\n    gy11 = gy11 - (sw11 * (step(vec4(0.0), gy11) - 0.5));\n\n    var g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    var g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    var g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    var g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    var g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    var g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    var g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    var g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    var g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    var g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    var g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    var g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    var g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    var g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    var g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    var g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    var norm00 = taylorInvSqrt4(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 = g0000 * norm00.x;\n    g0100 = g0100 * norm00.y;\n    g1000 = g1000 * norm00.z;\n    g1100 = g1100 * norm00.w;\n\n    var norm01 = taylorInvSqrt4(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 = g0001 * norm01.x;\n    g0101 = g0101 * norm01.y;\n    g1001 = g1001 * norm01.z;\n    g1101 = g1101 * norm01.w;\n\n    var norm10 = taylorInvSqrt4(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 = g0010 * norm10.x;\n    g0110 = g0110 * norm10.y;\n    g1010 = g1010 * norm10.z;\n    g1110 = g1110 * norm10.w;\n\n    var norm11 = taylorInvSqrt4(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 = g0011 * norm11.x;\n    g0111 = g0111 * norm11.y;\n    g1011 = g1011 * norm11.z;\n    g1111 = g1111 * norm11.w;\n\n    let n0000 = dot(g0000, Pf0);\n    let n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    let n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    let n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    let n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    let n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    let n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    let n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    let n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    let n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    let n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    let n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    let n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    let n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    let n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    let n1111 = dot(g1111, Pf1);\n\n    let fade_xyzw = quintic4(Pf0);\n    let n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    let n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    let n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    let n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    let n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return 2.2 * n_xyzw;\n}\n","lygia::generative::random":"/*\ncontributors:\n    - Patricio Gonzalez Vivo\n    - David Hoskins\n    - Inigo Quilez\ndescription: Pass a value and get some random normalize value between 0 and 1\nnotes:\n    - While the GLSL and HLSL versions of this file support a RANDOM_HIGHER_RANGE option, the current implementation has this permanently enabled.\noptions:\n    - RANDOM_SINLESS: Use sin-less random, which tolerates bigger values before producing pattern. From https://www.shadertoy.com/view/4djSRW\n    - RANDOM_SCALE: by default this scale if for number with a big range. For producing good random between 0 and 1 use bigger range\nexamples:\n    - /shaders/generative_random.frag\nlicense:\n    - MIT License (MIT) Copyright 2014, David Hoskins\n*/\n\nconst RANDOM_SINLESS: bool = true;\n\nconst RANDOM_SCALE: vec4f = vec4f(.1031, .1030, .0973, .1099);\n\nfn random(p: f32) -> f32 {\n    var x = p;\n    if (RANDOM_SINLESS) {\n        x = fract(x * RANDOM_SCALE.x);\n        x *= x + 33.33;\n        x *= x + x;\n        return fract(x);\n    } else {\n        return fract(sin(x) * 43758.5453);\n    }\n}\n\nfn random2(st: vec2f) -> f32 {\n    if (RANDOM_SINLESS) {\n        var p3  = fract(vec3(st.xyx) * RANDOM_SCALE.xyz);\n        p3 += dot(p3, p3.yzx + 33.33);\n        return fract((p3.x + p3.y) * p3.z);\n    } else {\n        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    }\n}\n\nfn random3(p: vec3f) -> f32 {\n    var pos = p;\n    if (RANDOM_SINLESS) {\n        pos  = fract(pos * RANDOM_SCALE.xyz);\n        pos += dot(pos, pos.zyx + 31.32);\n        return fract((pos.x + pos.y) * pos.z);\n    } else {\n        return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n    }\n}\n\nfn random4(p: vec4f) -> f32 {\n    var pos = p;\n    if (RANDOM_SINLESS) {\n        pos = fract(pos * RANDOM_SCALE);\n        pos += dot(pos, pos.wzxy+33.33);\n        return fract((pos.x + pos.y) * (pos.z + pos.w));\n    } else {\n        let dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n        return fract(sin(dot_product) * 43758.5453);\n    }\n}\n\nfn random21(p: f32) -> vec2f {\n    var p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfn random22(p: vec2f) -> vec2f {\n    var p3 = fract(p.xyx * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfn random23(p: vec3f) -> vec2f {\n    var p3 = p;\n    p3 = fract(p3 * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfn random31(p: f32) -> vec3f {\n    var p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nfn random32(p: vec2f) -> vec3f {\n    var p3 = fract(vec3(p.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nfn random33(p_: vec3f) -> vec3f {\n    var p = fract(p_ * RANDOM_SCALE.xyz);\n    p += dot(p, p.yxz + 19.19);\n    return fract((p.xxy + p.yzz) * p.zyx);\n}\n\nfn random41(p: f32) -> vec4f {\n    var p4 = fract(p * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nfn random42(p: vec2f) -> vec4f {\n    var p4 = fract(p.xyxy * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nfn random43(p: vec3f) -> vec4f {\n    var p4 = fract(p.xyzx  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nfn random44(p: vec4f) -> vec4f {\n    var p4 = p;\n    p4 = fract(p4  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n","lygia::generative::snoise":"import package::math::mod289::{mod289_2, mod289_3, mod289_4};\nimport package::math::permute::{permute, permute3, permute4};\nimport package::math::taylorInvSqrt::{taylorInvSqrt, taylorInvSqrt4};\nimport package::math::grad4::grad4;\n\n/*\ncontributors: [Stefan Gustavson, Ian McEwan]\ndescription: Simplex Noise https://github.com/stegu/webgl-noise\nuse: snoise2/3/4(<vec2f|vec3f|vec4f> pos)\nlicense: |\n    Copyright 2021-2023 by Stefan Gustavson and Ian McEwan.\n    Published under the terms of the MIT license:\n    https://opensource.org/license/mit/\n*/\n\nfn snoise2(v: vec2f) -> f32 {\n    let C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                 0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                 -0.577350269189626, // -1.0 + 2.0 * C.x\n                 0.024390243902439); // 1.0 / 41.0\n    // First corner\n    var i  = floor(v + dot(v, C.yy) );\n    let x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    let i1 = select(vec2(0.0, 1.0), vec2(1.0, 0.0), x0.x > x0.y);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    let x12 = x0.xyxy + C.xxzz - vec4(i1, 0.0, 0.0);\n\n    // Permutations\n    i = mod289_2(i); // Avoid truncation effects in permutation\n    let p = permute3( permute3( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    var m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), vec3(0.0));\n    m = m*m;\n    m = m*m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    let x = 2.0 * fract(p * C.www) - 1.0;\n    let h = abs(x) - 0.5;\n    let ox = floor(x + 0.5);\n    let a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    let gx  = a0.x  * x0.x  + h.x  * x0.y;\n    let gyz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, vec3(gx, gyz));\n}\n\nfn snoise3(v: vec3f) -> f32 {\n    let C = vec2(1.0/6.0, 1.0/3.0) ;\n    let D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    var i  = floor(v + dot(v, C.yyy) );\n    let x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    let g = step(x0.yzx, x0.xyz);\n    let l = 1.0 - g;\n    let i1 = min( g.xyz, l.zxy );\n    let i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    let x1 = x0 - i1 + C.xxx;\n    let x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    let x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289_3(i);\n    let p = permute4( permute4( permute4(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    let n_ = 0.142857142857; // 1.0/7.0\n    let  ns = n_ * D.wyz - D.xzx;\n\n    let j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    let x_ = floor(j * ns.z);\n    let y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    let x = x_ *ns.x + ns.yyyy;\n    let y = y_ *ns.x + ns.yyyy;\n    let h = 1.0 - abs(x) - abs(y);\n\n    let b0 = vec4( x.xy, y.xy );\n    let b1 = vec4( x.zw, y.zw );\n\n    //let s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //let s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    let s0 = floor(b0)*2.0 + 1.0;\n    let s1 = floor(b1)*2.0 + 1.0;\n    let sh = -step(h, vec4(0.0));\n\n    let a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    let a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    var p0 = vec3(a0.xy,h.x);\n    var p1 = vec3(a0.zw,h.y);\n    var p2 = vec3(a1.xy,h.z);\n    var p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    let norm = taylorInvSqrt4(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    var m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), vec4(0.0));\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfn snoise4(v: vec4f) -> f32 {\n    let C = vec4(0.138196601125011,   // (5 - sqrt(5))/20  G4\n                 0.276393202250021,   // 2 * G4\n                 0.414589803375032,   // 3 * G4\n                 -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    var i  = floor(v + dot(v, vec4(.309016994374947451)) ); // (sqrt(5) - 1)/4\n    let x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    let isX = step( x0.yzw, x0.xxx );\n    let isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    var i0 = vec4(isX.x + isX.y + isX.z, 1.0 - isX);\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0 += vec4(0.0, isYZ.x + isYZ.y, 1.0 - isYZ.xy);\n    i0 += vec4(0.0, 0.0, isYZ.z, 1.0 - isYZ.z);\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    let i3 = clamp( i0, vec4(0.0), vec4(1.0) );\n    let i2 = clamp( i0 - 1.0, vec4(0.0), vec4(1.0) );\n    let i1 = clamp( i0 - 2.0, vec4(0.0), vec4(1.0) );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    let x1 = x0 - i1 + C.xxxx;\n    let x2 = x0 - i2 + C.yyyy;\n    let x3 = x0 - i3 + C.zzzz;\n    let x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289_4(i);\n    let j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    let j1 = permute4( permute4( permute4( permute4 (\n                i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n            + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n            + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n            + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    let ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    var p0 = grad4(j0,   ip);\n    var p1 = grad4(j1.x, ip);\n    var p2 = grad4(j1.y, ip);\n    var p3 = grad4(j1.z, ip);\n    var p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    let norm = taylorInvSqrt4(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    var m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), vec3(0.0));\n    var m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), vec2(0.0));\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nfn snoise22(x: vec2f) -> vec2f {\n    let s  = snoise2(vec2( x ));\n    let s1 = snoise2(vec2( x.y - 19.1, x.x + 47.2 ));\n    return vec2( s , s1 );\n}\n\nfn snoise33(x: vec3f) -> vec3f {\n    let s  = snoise3(vec3( x ));\n    let s1 = snoise3(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n    let s2 = snoise3(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n    return vec3( s , s1 , s2 );\n}\n\nfn snoise34(x: vec4f) -> vec3f {\n    let s  = snoise4(vec4( x ));\n    let s1 = snoise4(vec4( x.y - 19.1 , x.z + 33.4 , x.x + 47.2, x.w ));\n    let s2 = snoise4(vec4( x.z + 74.2 , x.x - 124.5 , x.y + 99.4, x.w ));\n    return vec3( s , s1 , s2 );\n}\n","lygia::generative::srandom":"import package::math::mod::{mod2, mod3};\n\n/*\ncontributors:\n    - Patricio Gonzalez Vivo\ndescription: Signed Random\nuse:\n    - <f32> srandom(<f32>)\n    - <f32> srandom2(<vec2f>)\n    - <f32> srandom3(<vec3f>)\n    - <f32> srandom4(<vec4f>)\n    - <vec2> srandom22(<vec2f>)\n    - <vec3> srandom33(<vec3f>)\n    - <vec4> srandom44(<vec4f>)\n    - <vec3> srandom_tile22(<vec2f>, <f32>)\n    - <vec4> srandom_tile33(<vec3f>, <f32>)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn srandom(x: f32) -> f32 {\n    return -1. + 2. * fract(sin(x) * 43758.5453);\n}\n\nfn srandom2(st: vec2f) -> f32 {\n    return -1. + 2. * fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfn srandom3(pos: vec3f) -> f32 {\n    return -1. + 2. * fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n}\n\nfn srandom4(pos: vec4f) -> f32{\n    let dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return -1. + 2. * fract(sin(dot_product) * 43758.5453);\n}\n\nfn srandom22(st: vec2f) -> vec2f {\n    let k = vec2(.3183099, .3678794);\n    let tmp = st * k + k.yx;\n    return -1. + 2. * fract(16. * k * fract(tmp.x * tmp.y * (tmp.x + tmp.y)));\n}\n\nfn srandom33(p: vec3f) -> vec3f {\n    let tmp = vec3( dot(p, vec3(127.1, 311.7, 74.7)),\n            dot(p, vec3(269.5, 183.3, 246.1)),\n            dot(p, vec3(113.5, 271.9, 124.6)));\n    return -1. + 2. * fract(sin(tmp) * 43758.5453123);\n}\n\nfn srandom_tile22(p: vec2f, tileLength: f32) -> vec2f {\n    let tmp = mod2(p, vec2(tileLength));\n    return srandom22(tmp);\n}\n\nfn srandom_tile33(p: vec3f, tileLength: f32) -> vec3f {\n    let tmp = mod3(p, vec3(tileLength));\n    return srandom33(tmp);\n}\n","lygia::generative::wavelet":"import package::generative::random::random2;\nimport package::math::rotate2d::rotate2d;\n\n/*\ncontributors: Martijn Steinrucken\ndescription: Wavelet noise https://www.shadertoy.com/view/wsBfzK\nuse: <vec2> worley(<vec2|vec3> pos)\noptions:\n    - WAVELET_VORTICITY: amount of vorticity, i.e. spinning behaviour. With 0.0 (none) being the default, values may exceed 1.0.\nexamples:\n    - /shaders/generative_worley.frag\nlicense:\n    - The MIT License Copyright 2020 Martijn Steinrucken\n*/\n\nconst WAVELET_VORTICITY: f32 = 0.0;\n\nfn wavelet(p: vec2f, phase: f32, scale: f32) -> f32 {\n    var d = 0.0; \n    var s = 1.0;\n    var m = 0.0;\n    var a = 0.0;\n    var tmp = p;\n    for (var i = 0.0; i < 4.0; i += 1.0) {\n        var q = tmp*s;\n        a = random2(floor(q)) * 1e3;\n        a += phase * random2(floor(q)) * WAVELET_VORTICITY;\n        q = (fract(q) - 0.5) * rotate2d(a);\n        d += sin(q.x * 10.0 + phase) * smoothstep(.25, 0.0, dot(q,q)) / s;\n        tmp = tmp * mat2x2(0.54,-0.84, 0.84, 0.54) + i;\n        m += 1.0 / s;\n        s *= scale; \n    }\n    return d / m;\n}\n\nfn waveletScaled3(p: vec3f, scale: f32) -> f32 {\n    return wavelet(p.xy, p.z, scale);\n}\n\nfn wavelet3(p: vec3f) -> f32 {\n    return wavelet(p.xy, p.z, 1.24);\n} \n\nfn waveletScaled2(p: vec2f, phase: f32) -> f32 {\n    return wavelet(p, phase, 1.24);\n} \n\nfn wavelet2(p: vec2f) -> f32 {\n    return wavelet(p, 0.0, 1.24);\n} \n","lygia::generative::worley":"import package::generative::random::{random22, random33};\nimport package::math::dist::{distEuclidean2, distEuclidean3};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Worley noise. Returns vec2(F1, F2)\nuse: <vec2> worley2(<vec2|vec3> pos)\nnotes:\n    - While the GLSL and HLSL versions of this file support other distance functions, WGSL does not have a standard way to do this. As such, the current implementation uses distEuclidean.\noptions:\n    - WORLEY_JITTER: amount of pattern randomness. With 1.0 being the default and 0.0 resulting in a perfectly symmetrical pattern.\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/generative_worley.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nconst WORLEY_JITTER: f32 = 1.0;\n\nfn worley22(p: vec2f) -> vec2f {\n    let n = floor( p );\n    let f = fract( p );\n\n    var distF1 = 1.0;\n    var distF2 = 1.0;\n    var off1 = vec2(0.0); \n    var pos1 = vec2(0.0);\n    var off2 = vec2(0.0);\n    var pos2 = vec2(0.0);\n    for(var j = -1; j <= 1; j++) {\n        for(var i = -1; i <= 1; i++) {\t\n            let  g = vec2(f32(i), f32(j));\n            let  o = random22( n + g ) * WORLEY_JITTER;\n            let  p = g + o;\n            let d = distEuclidean2(p, f);\n            if (d < distF1) {\n                distF2 = distF1;\n                distF1 = d;\n                off2 = off1;\n                off1 = g;\n                pos2 = pos1;\n                pos1 = p;\n            }\n            else if (d < distF2) {\n                distF2 = d;\n                off2 = g;\n                pos2 = p;\n            }\n        }\n    }\n\n    return vec2(distF1, distF2);\n}\n\nfn worley2(p: vec2f) -> f32 { return 1.0-worley22(p).x; }\n\nfn worley32(p: vec3f) -> vec2f {\n    let n = floor( p );\n    let f = fract( p );\n\n    var distF1 = 1.0;\n    var distF2 = 1.0;\n    var off1 = vec3(0.0);\n    var pos1 = vec3(0.0);\n    var off2 = vec3(0.0);\n    var pos2 = vec3(0.0);\n    for(var k = -1; k <= 1; k++) {\n        for(var j = -1; j <= 1; j++) {\n            for(var i=-1; i <= 1; i++) {\t\n                let  g = vec3(f32(i), f32(j), f32(k));\n                let  o = random33( n + g ) * WORLEY_JITTER;\n                let  p = g + o;\n                let d = distEuclidean3(p, f);\n                if (d < distF1) {\n                    distF2 = distF1;\n                    distF1 = d;\n                    off2 = off1;\n                    off1 = g;\n                    pos2 = pos1;\n                    pos1 = p;\n                }\n                else if (d < distF2) {\n                    distF2 = d;\n                    off2 = g;\n                    pos2 = p;\n                }\n            }\n        }\n    }\n\n    return vec2(distF1, distF2);\n}\n\nfn worley3(p: vec3f) -> f32 { return 1.0-worley32(p).x; }\n","lygia::lighting::common::ggx":"fn GGX(N: vec3f, H: vec3f, NoH: f32, roughness: f32) -> f32 {\n    let NxH = cross(N, H);\n    let oneMinusNoHSquared = dot(NxH, NxH);\n\n    // let oneMinusNoHSquared = 1.0 - NoH * NoH;\n\n    let a = NoH * roughness;\n    let k = roughness / (oneMinusNoHSquared + a * a);\n    let d = (k * k) * 0.31830988618379067153776752674503; // 1/PI\n    return min(d, 65504.0);\n}\n","lygia::lighting::common::schlick":"fn schlick(f0: vec3f, f90: vec3f, cos0: f32) -> vec3f {\n    return f0 + (f90 - f0) * pow(1.0 - cos0, 5.0);\n}\n","lygia::lighting::diffuse::orenNayar":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Calculate diffuse contribution using Oren and Nayar equation https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn diffuseOrenNayar(L: vec3f, N: vec3f, V: vec3f, NoV: f32, NoL: f32, roughness: f32) -> f32 {\n    let LoV = dot(L, V);\n    \n    let s = LoV - NoL * NoV;\n    let t = mix(1.0, max(NoL, NoV), step(0.0, s));\n\n    let sigma2 = roughness * roughness;\n    let A = 1.0 + sigma2 * (1.0 / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n    let B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n    return max(0.0, NoL) * (A + B * s / t);\n}\n","lygia::lighting::fresnel":"import package::lighting::common::schlick::schlick;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Resolve fresnel coefficient\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn fresnel(f0: f32, NoV: f32) -> f32 {\n    return schlick(f0, 1.0, NoV);\n}\n","lygia::lighting::fresnelReflection":"import package::lighting::{fresnel::fresnel, envMap::envMap};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: \"Resolve fresnel coefficient and apply it to a reflection. It can apply\\\n    \\ iridescence to \\nusing a formula based on https://www.alanzucconi.com/2017/07/25/the-mathematics-of-thin-film-interference/\\n\"\nuse:\n    - <vec3> fresnelReflection(<vec3> R, <vec3> f0, <float> NoV)\n    - <vec3> fresnelIridescentReflection(<vec3> normal, <vec3> view, <vec3> f0, <vec3> ior1, <vec3> ior2, <float> thickness, <float> roughness)\n    - <vec3> fresnelReflection(<Material> _M)\noptions:\n    - FRESNEL_REFLECTION_RGB: <vec3> RGB values of the reflection\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn fresnelReflection(R: vec3f, f0: vec3f, NoV: f32) -> vec3f {\n    let frsnl = fresnel(f0, NoV);\n\n    let reflectColor = vec3f(0.0);\n    reflectColor = envMap(R, 1.0, 0.001);\n\n    return reflectColor * frsnl;\n}\n","lygia::lighting::raymarch::cast":"/*\ncontributors: Inigo Quiles\ndescription: Cast a ray\n*/\n\nimport package::math::map::map;\n\nfn raymarchCast(ro: vec3f, rd: vec3f ) -> f32 {\n    var dist = -1.0;\n    var t = -1.0;\n    for (var i = 0; i < 120 && t < 100.0; i++) {\n        let h = map( ro + rd * t );\n        if (abs(h) < (0.001 * t)) { \n            dist = t; \n            break;\n        }\n        t += h;\n    }\n    return dist;\n}\n","lygia::lighting::raymarch::normal":"import package::math::map::map;\n\n/*\ncontributors: Inigo Quiles\ndescription: Calculate normals http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nexamples:\n    - /shaders/lighting_raymarching.frag\n\n*/\n\nfn raymarchNormal( pos: vec3f ) -> vec3f {\n    let eps = 0.002;\n    let v1 = vec3f( 1.0,-1.0,-1.0);\n    let v2 = vec3f(-1.0,-1.0, 1.0);\n    let v3 = vec3f(-1.0, 1.0,-1.0);\n    let v4 = vec3f( 1.0, 1.0, 1.0);\n    return normalize( v1 * map( pos + v1 * eps ) +\n                      v2 * map( pos + v2 * eps ) +\n                      v3 * map( pos + v3 * eps ) +\n                      v4 * map( pos + v4 * eps ) );\n}\n","lygia::lighting::specular::cookTorrance":"import package::lighting::common::ggx::GGX;\n\nfn specularCookTorrance(L: vec3f, N: vec3f, V: vec3f, NoV: f32, NoL: f32, roughness: f32, fresnel: f32) -> f32 {\n    // Half angle vector\n    let H = normalize(L + V);\n\n    // Geometric term\n    let NoH = max(dot(N, H), 0.0);\n    let VoH = max(dot(V, H), 0.000001);\n\n    let x = 2.0 * NoH / VoH;\n    let G = min(1.0, min(x * NoV, x * NoL));\n    \n    // Distribution term\n    let D = GGX(N, H, NoH, roughness);\n\n    // Fresnel term\n    let F = pow(1.0 - NoV, fresnel);\n\n    // Multiply terms and done\n    return max(G * F * D / max(PI * NoV * NoL, 0.00001), 0.0);\n}\n","lygia::lighting::toShininess":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Convertes from PBR roughness/metallic to a shininess factor (typaclly use on diffuse/specular/ambient workflow)\nuse: <f32> toShininess(<f32> roughness, <f32> metallic)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn toShininess(roughness: f32, metallic: f32) -> f32 {\n    var s = 0.95 - roughness * 0.5;\n    s *= s;\n    s *= s;\n    return s * (80.0 + 160.0 * (1.0-metallic));\n}\n","lygia::math::aafloor":"import package::math::map::map;\n\n/*\ncontributors: [\"dahart\", \"Fabrice NEYRET\"]\ndescription: |\n    Is similar to floor() but has a 2-pixel wide gradient between clamped steps \n    to allow the edges in the result to be anti-aliased.\n    Based on examples https://www.shadertoy.com/view/4l2BRD and https://www.shadertoy.com/view/3tSGWy\n*/\n\nfn aafloor(x: f32) -> f32 {\n    let afwidth = 2.0 * fwidth(x);\n    let fx = fract(x);\n    let idx = 1. - afwidth;\n    return select(map(fx, idx, 1., x-fx, x), x - fx, fx < idx);\n}\n\nfn aafloor2(x: vec2f) -> vec2f { return vec2f(aafloor(x.x), aafloor(x.y)); }\n","lygia::math::aafract":"import package::math::map::map;\n\n/*\ncontributors: dahart (https://www.shadertoy.com/user/dahart)\ndescription: |\n    Anti-aliasing fract function. It clamp except for a 2-pixel wide gradient along the edge\n    Based on this example https://www.shadertoy.com/view/4l2BRD\n*/\n\nfn aafract(x: f32) -> f32 {\n    let afwidth = 2.0 * fwidth(x);\n    let fx = fract(x);\n    let idx = 1.0 - afwidth;\n    return select(map(fx, idx, 1., fx, 0.), fx, fx < idx);\n}\n\nfn aafract2(v: vec2f) -> vec2f { return vec2(aafract(v.x), aafract(v.y)); }\n","lygia::math::aastep":"/*\ncontributors: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\n*/\n\nfn aastep(threshold: f32, value: f32) -> f32 {\n    let afwidth = 0.7 * fwidth(value);\n    return smoothstep(threshold - afwidth, threshold + afwidth, value);\n}","lygia::math::adaptiveThreshold":"/*\ncontributors: [Brad Larson, Ben Cochran, Hugues Lismonde, Keitaroh Kobayashi, Alaric Cole, Matthew Clark, Jacob Gundersen, Chris Williams]\ndescription: adaptive threshold from https://github.com/BradLarson/GPUImage/blob/master/framework/Source/GPUImageAdaptiveThresholdFilter.m\n*/\n\nfn adaptiveThreshold(v: f32, blur_v: f32, b: f32) -> f32 { return step(blur_v + b, v); }\n","lygia::math::bump":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: bump in a range between -1 and 1\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn bump(x: f32, k: f32) -> f32 { return saturate( (1.0 - x * x) - k); }\nfn bump2(x: vec2f, k: vec2f) -> vec2f { return saturate( (1.0 - x * x) - k); }\nfn bump3(x: vec3f, k: vec3f) -> vec3f { return saturate( (1.0 - x * x) - k); }\nfn bump4(x: vec4f, k: vec4f) -> vec4f { return saturate( (1.0 - x * x) - k); }\n","lygia::math::consts":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: some useful math constants\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nconst EIGHTH_PI: f32 = 0.39269908169;\nconst QTR_PI: f32 = 0.78539816339;\nconst HALF_PI: f32 = 1.5707963267948966192313216916398;\nconst PI: f32 = 3.1415926535897932384626433832795;\nconst TWO_PI: f32 = 6.2831853071795864769252867665590;\nconst TAU: f32 = 6.2831853071795864769252867665590;\nconst INV_PI: f32 = 0.31830988618379067153776752674503;\nconst INV_SQRT_TAU = 0.39894228040143267793994605993439;\nconst SQRT_HALF_PI: f32 = 1.25331413732;\nconst PHI: f32 = 1.618033988749894848204586834;\nconst EPSILON: f32 = 0.0000001;\nconst GOLDEN_RATIO: f32 = 1.6180339887;\nconst GOLDEN_RATIO_CONJUGATE: f32 = 0.61803398875;\nconst GOLDEN_ANGLE: f32 = 2.39996323;\n// const DEG2RAD: f32 = PI / 180.0;\n// const RAD2DEG: f32 = 180.0 / PI;\n","lygia::math::cubic":"/*\ncontributors: Inigo Quiles\ndescription: cubic polynomial https://iquilezles.org/articles/smoothsteps/\n*/\n\nfn cubic(v: f32) -> f32 { return v*v*(3.0-2.0*v); }\nfn cubic2(v: vec2f) -> vec2f { return v*v*(3.0-2.0*v); }\nfn cubic3(v: vec3f) -> vec3f { return v*v*(3.0-2.0*v); }\nfn cubic4(v: vec4f) -> vec4f { return v*v*(3.0-2.0*v); }\n","lygia::math::cubicMix":"import package::math::cubic::{cubic, cubic2, cubic3, cubic4};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: cubic polynomial interpolation between two values\nuse: <float|vec2|vec3|vec4> cubicMix(<float|vec2|vec3|vec4> A, <float|vec2|vec3|vec4> B, float t)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/math_functions.frag\n*/\n\nfn cubicMix(A: f32, B: f32, t: f32) -> f32 { return A + (B - A) * cubic(t); }\nfn cubicMix2(A: vec2f, B: vec2f, t: vec2f) -> vec2f { return A + (B - A) * cubic2(t); }\nfn cubicMix3(A: vec3f, B: vec3f, t: vec3f) -> vec3f { return A + (B - A) * cubic3(t); }\nfn cubicMix4(A: vec4f, B: vec4f, t: vec4f) -> vec4f { return A + (B - A) * cubic4(t); }\n","lygia::math::decimate":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: decimate a value with an specific precision\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn decimate(v: f32, d:f32) -> f32 { return floor(v * d) / d; }\nfn decimate2(v: vec2f, d:vec2f) -> vec2f { return floor(v * d) / d; }\nfn decimate3(v: vec3f, d:vec3f) -> vec3f { return floor(v * d) / d; }\nfn decimate4(v: vec4f, d:vec4f) -> vec4f { return floor(v * d) / d; }\n","lygia::math::dist":"/*\ncontributors: Shadi El Hajj\ndescription: Commonly used distance functions.\nnotes:\n    - While the GLSL and HLSL versions of this file support defining the default distance function (DIST_FNC), WGSL does not have a standard way to do this. As such, the current implementation uses distEuclidean.\noptions:\n    - DIST_MINKOWSKI_P: the power of the Minkowski distance function (1.0 Manhattan, 2.0 Euclidean, Infinity Chebychev)\nlicense: MIT License (MIT) Copyright (c) 2024 Shadi EL Hajj\n*/\n\nconst DIST_MINKOWSKI_P: f32 = 2.0; // 1: Manhattan, 2: Euclidean, Infinity: Chebychev\n\nfn distEuclidean2(a: vec2f, b: vec2f) -> f32 { return distance(a, b); }\nfn distEuclidean3(a: vec3f, b: vec3f) -> f32 { return distance(a, b); }\nfn distEuclidean4(a: vec4f, b: vec4f) -> f32 { return distance(a, b); }\n\n// https://en.wikipedia.org/wiki/Taxicab_geometry\nfn distManhattan2(a: vec2f, b: vec2f) -> f32 { return abs(a.x - b.x) + abs(a.y - b.y); }\nfn distManhattan3(a: vec3f, b: vec3f) -> f32 { return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z); }\nfn distManhattan4(a: vec4f, b: vec4f) -> f32 { return abs(a.x - b.x) + abs(a.y - b.y) + abs(a.z - b.z) + abs(a.w - b.w); }\n\n// https://en.wikipedia.org/wiki/Chebyshev_distance\nfn distChebychev2(a: vec2f, b: vec2f) -> f32 { return max(abs(a.x - b.x), abs(a.y - b.y)); }\nfn distChebychev3(a: vec3f, b: vec3f) -> f32 { return max(abs(a.x - b.x), max(abs(a.y - b.y), abs(a.z - b.z))); }\nfn distChebychev4(a: vec4f, b: vec4f) -> f32 { return max(abs(a.x - b.x), max(abs(a.y - b.y), max(abs(a.z - b.z), abs(a.w - b.w) ))); }\n\n// https://en.wikipedia.org/wiki/Minkowski_distance\nfn distMinkowski2(a: vec2f, b: vec2f) -> f32 { return  pow(pow(abs(a.x - b.x), DIST_MINKOWSKI_P) + pow(abs(a.y - b.y), DIST_MINKOWSKI_P), 1.0 / DIST_MINKOWSKI_P); }\nfn distMinkowski3(a: vec3f, b: vec3f) -> f32 { return  pow(pow(abs(a.x - b.x), DIST_MINKOWSKI_P) + pow(abs(a.y - b.y), DIST_MINKOWSKI_P) + pow(abs(a.z - b.z), DIST_MINKOWSKI_P), 1.0 / DIST_MINKOWSKI_P); }\nfn distMinkowski4(a: vec4f, b: vec4f) -> f32 { return  pow(pow(abs(a.x - b.x), DIST_MINKOWSKI_P) + pow(abs(a.y - b.y), DIST_MINKOWSKI_P) + pow(abs(a.z - b.z), DIST_MINKOWSKI_P) + pow(abs(a.w - b.w), DIST_MINKOWSKI_P), 1.0 / DIST_MINKOWSKI_P); }\n\nfn dist2(a: vec2f, b: vec2f) -> f32 { return distEuclidean2(a, b); }\nfn dist3(a: vec3f, b: vec3f) -> f32 { return distEuclidean3(a, b); }\nfn dist4(a: vec4f, b: vec4f) -> f32 { return distEuclidean4(a, b); }\n","lygia::math::gain":"/*\ncontributors: Inigo Quiles\ndescription: |\n    Remapping the unit interval into the unit interval by expanding the sides and compressing the center, and keeping 1/2 mapped to 1/2, that can be done with the gain() function. From https://iquilezles.org/articles/functions/\n*/\n\nfn gain(x: f32, k: f32) -> f32 {\n    let a = 0.5 * pow(2.0 * select(1.0-x, x, x<0.5), k);\n    return select(1.0-a, a, x<0.5);\n}\n","lygia::math::gaussian":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: gaussian coefficient\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn gaussian(d: f32, sigma: f32) -> f32 { return exp(-(d*d) / (2.0 * sigma * sigma)); }\nfn gaussian2(d: vec2f, sigma: f32) -> f32 { return exp(-(d.x*d.x + d.y*d.y) / (2.0 * sigma * sigma));  }\nfn gaussian3(d: vec3f, sigma: f32) -> f32 { return exp(-(d.x*d.x + d.y*d.y + d.z*d.z) / (2.0 * sigma * sigma)); }\nfn gaussian4(d: vec4f, sigma: f32) -> f32 { return exp(-(d.x*d.x + d.y*d.y + d.z*d.z + d.w*d.w) / (2.0 * sigma * sigma)); }\n","lygia::math::grad4":"/*\ncontributors: [Stefan Gustavson, Ian McEwan]\ndescription: grad4, used for snoise(vec4 v)\n*/\n\nfn grad4(j: f32, ip: vec4f) -> vec4f {\n    let ones = vec4(1.0, 1.0, 1.0, -1.0);\n    var xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    let w = 1.5 - dot(abs(xyz), ones.xyz);\n    let s = select(vec4(0.0), vec4(1.0), vec4(xyz, w) < vec4(0.0));\n    xyz = xyz + (s.xyz*2.0 - 1.0) * s.www;\n    return vec4f(xyz, w);\n}\n","lygia::math::highPass":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: bias high pass\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn highPass(v: f32, b: f32) -> f32 { return max(v - b, 0.0) / (1.0 - b); }\n","lygia::math::inside":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: does the position lie within the triangle\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn inside(_x: f32, _min: f32, _max: f32) -> bool { return !(_x < _min || _x > _max); }\n\nfn inside2(_v: vec2f, _min: vec2f, _max: vec2f) -> bool {\n    return !(_v.x < _min.x || _v.x > _max.x || \n             _v.y < _min.y || _v.y > _max.y);\n}\n\nfn inside3(_v: vec3f, _min: vec3f, _max: vec3f) -> bool {\n    return !(_v.x < _min.x || _v.x > _max.x || \n             _v.y < _min.y || _v.y > _max.y ||\n             _v.z < _min.z || _v.z > _max.z);\n}\n\nfn insideAABB(_v: vec2f, _aabb: vec4f) -> bool { return inside(_v, _aabb.xy, _aabb.zw); }\n","lygia::math::invCubic":"/*\ncontributors: Inigo Quiles\ndescription: inverse cubic polynomial https://iquilezles.org/articles/smoothsteps/\n*/\n\nfn invCubic(v: f32) -> f32 { return 0.5-sin(asin(1.0-2.0*v)/3.0); }\nfn invCubic2(v: vec2f) -> vec2f { return 0.5-sin(asin(1.0-2.0*v)/3.0); }\nfn invCubic3(v: vec3f) -> vec3f { return 0.5-sin(asin(1.0-2.0*v)/3.0); }\nfn invCubic4(v: vec4f) -> vec4f { return 0.5-sin(asin(1.0-2.0*v)/3.0); }\n","lygia::math::invQuartic":"/*\ncontributors: Inigo Quiles\ndescription: inverse quartic polynomial https://iquilezles.org/articles/smoothsteps/\n*/\n\nfn invQuartic(v: f32) -> f32 { return sqrt(1.0-sqrt(1.0-v)); }\nfn invQuartic2(v: vec2f) -> vec2f { return sqrt(1.0-sqrt(1.0-v)); }\nfn invQuartic3(v: vec3f) -> vec3f { return sqrt(1.0-sqrt(1.0-v)); }\nfn invQuartic4(v: vec4f) -> vec4f { return sqrt(1.0-sqrt(1.0-v)); }\n","lygia::math::inverse":"/*\ncontributors: Mikola Lysenko\ndescription: inverse matrixes\n*/\n\nfn inverse(m: mat3x3<f32>) -> mat3x3<f32> {\n    let a00 = m[0][0];\n    let a01 = m[0][1];\n    let a02 = m[0][2];\n    let a10 = m[1][0];\n    let a11 = m[1][1];\n    let a12 = m[1][2];\n    let a20 = m[2][0];\n    let a21 = m[2][1];\n    let a22 = m[2][2];\n\n    let b01 = a22 * a11 - a12 * a21;\n    let b11 = -a22 * a10 + a12 * a20;\n    let b21 = a21 * a10 - a11 * a20;\n\n    let det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    let A = vec3f(b01, (-a22 * a01 + a02 * a21), ( a12 * a01 - a02 * a11)) / det;\n    let B = vec3f(b11, ( a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10)) / det;\n    let C = vec3f(b21, (-a21 * a00 + a01 * a20), ( a11 * a00 - a01 * a10)) / det;\n\n    return mat3x3<f32>(A, B, C);\n}\n","lygia::math::lengthSq":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Squared length\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn lengthSq2(v: vec2f) -> f32 { return dot(v, v); }\nfn lengthSq3(v: vec3f) -> f32 { return dot(v, v); }\nfn lengthSq4(v: vec4f) -> f32 { return dot(v, v); }\n","lygia::math::map":"/*\ncontributors: Johan Ismael\ndescription: Map a v between one range to another.\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn map(v: f32, iMin: f32, iMax: f32, oMin: f32, oMax: f32) -> f32 { return oMin + (oMax - oMin) * (v - iMin) / (iMax - iMin); }\nfn map2(v: vec2f, iMin: vec2f, iMax: vec2f, oMin: vec2f, oMax: vec2f) -> vec2f { return oMin + (oMax - oMin) * (v - iMin) / (iMax - iMin); }\nfn map3(v: vec3f, iMin: vec3f, iMax: vec3f, oMin: vec3f, oMax: vec3f) -> vec3f { return oMin + (oMax - oMin) * (v - iMin) / (iMax - iMin); }\nfn map4(v: vec4f, iMin: vec4f, iMax: vec4f, oMin: vec4f, oMax: vec4f) -> vec4f { return oMin + (oMax - oMin) * (v - iMin) / (iMax - iMin); }\n","lygia::math::mirror":"/*\ncontributors: Ian Heisters\ndescription: Transforms the input signal into a triangle wave. For instance, if x goes between 0 and 2, the returned value will go from 0 to 1, and then 1 to 0 in a triangle shape.\n*/\n\nfn mirror(x: f32) -> f32 {\n    let f = fract(x);\n    let m = floor(x % 2.0);\n    let fm = f * m;\n    return f + m - fm * 2.0;\n}\n\nfn mirror2(xy: vec2f) -> vec2f {\n    let f = fract(xy);\n    let m = floor(xy % 2.0);\n    let fm = f * m;\n    return f + m - fm * 2.0;\n}\n","lygia::math::mmax":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: extend GLSL Max function to add more arguments\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn mmax2(v: vec2f) -> f32 { return max(v.x, v.y); }\nfn mmax3(v: vec3f) -> f32 { return max(max(v.x, v.y), v.z); }\nfn mmax4(v: vec4f) -> f32 { return max(max(max(v.x, v.y), v.z), v.w); }\n","lygia::math::mmin":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: extend GLSL min function to add more arguments\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn mmin2(v: vec2f) -> f32 { return min(v.x, v.y); }\nfn mmin3(v: vec3f) -> f32 { return min(min(v.x, v.y), v.z); }\nfn mmin4(v: vec4f) -> f32 { return min(min(min(v.x, v.y), v.z), v.w); }\n","lygia::math::mod":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: An implementation of mod that matches the GLSL mod.\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn mod2(x: vec2f, y: vec2f) -> vec2f { return x - y * floor(x / y); }\nfn mod3(x: vec3f, y: vec3f) -> vec3f { return x - y * floor(x / y); }\nfn mod4(x: vec4f, y: vec4f) -> vec4f { return x - y * floor(x / y); }\n","lygia::math::mod289":"/*\ncontributors: [Stefan Gustavson, Ian McEwan]\ndescription: modulus of 289\n*/\n\nfn mod289(x: f32) -> f32 { return x - floor(x * (1. / 289.)) * 289.; }\nfn mod289_2(x: vec2f) -> vec2f { return x - floor(x * (1. / 289.)) * 289.; }\nfn mod289_3(x: vec3f) -> vec3f { return x - floor(x * (1. / 289.)) * 289.; }\nfn mod289_4(x: vec4f) -> vec4f { return x - floor(x * (1. / 289.)) * 289.; }\n","lygia::math::pack":"/*\ncontributors: Ricardo Caballero\ndescription: |\n    Pack a float into a 4D vector. From https://github.com/mrdoob/three.js/blob/acdda10d5896aa10abdf33e971951dbf7bd8f074/src/renderers/shaders/ShaderChunk/packing.glsl\n*/\n\nconst PackUpscale: f32 = 256. / 255.; // fraction -> 0..1 (including 1)\nconst UnpackDownscale: f32 = 255. / 256.; // 0..1 -> fraction (excluding 1)\nconst PackFactors = vec3f( 256. * 256. * 256., 256. * 256.,  256. );\nconst UnpackFactors = UnpackDownscale / vec4f( PackFactors, 1. );\nconst ShiftRight8: f32 = 1. / 256.;\n\nfn pack(v: f32) -> vec4f {\n    var r = vec4( fract( v * PackFactors ), v );\n    r.yzw -= r.xyz * ShiftRight8; // tidy overflow\n    return r * PackUpscale;\n}\n","lygia::math::parabola":"/*\ncontributors: Inigo Quiles\ndescription: |\n    A nice choice to remap the 0..1 interval into 0..1, such that the corners are mapped to 0 and the center to 1. You can then rise the parabolar to a power k to control its shape. From https://iquilezles.org/articles/functions/\n*/\n\nfn parabola(x: f32, k: f32) -> f32 { return pow( 4.0*x*(1.0-x), k ); }\n","lygia::math::permute":"import package::math::mod289::{mod289, mod289_2, mod289_3, mod289_4};\n\n/*\ncontributors: [Stefan Gustavson, Ian McEwan]\ndescription: permute\n*/\n\nfn permute(x: f32) -> f32 { return mod289(((x * 34.0) + 1.0) * x); }\nfn permute2(x: vec2f) -> vec2f { return mod289_2(((x * 34.0) + 1.0) * x); }\nfn permute3(x: vec3f) -> vec3f { return mod289_3(((x * 34.0) + 1.0) * x); }\nfn permute4(x: vec4f) -> vec4f { return mod289_4(((x * 34.0) + 1.0) * x); }\n","lygia::math::powFast":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: fast approximation to pow()\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn powFast(a: f32, b: f32) -> f32 { return a / ((1.0 - b) * a + b); }\nfn powFast2(a: vec2f, b: vec2f) -> vec2f { return a / ((1.0 - b) * a + b); }\nfn powFast3(a: vec3f, b: vec3f) -> vec3f { return a / ((1.0 - b) * a + b); }\nfn powFast4(a: vec4f, b: vec4f) -> vec4f { return a / ((1.0 - b) * a + b); }\n","lygia::math::quartic":"/*\ncontributors: Inigo Quiles\ndescription: quartic polynomial https://iquilezles.org/articles/smoothsteps/\n*/\n\nfn quartic(v: f32) -> f32 { return v*v*(2.0-v*v); }\nfn quartic2(v: vec2f) -> vec2f { return v*v*(2.0-v*v); }\nfn quartic3(v: vec3f) -> vec3f { return v*v*(2.0-v*v); }\nfn quartic4(v: vec4f) -> vec4f { return v*v*(2.0-v*v); }\n","lygia::math::quat":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: |\n    creates a quaternion (QUAT) from a given radian of rotation about a given axis or from a given forward vector and up vector\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n// A given r of rotation about a given axis\nfn quat(axis: vec3f, r: f32) -> vec4f {\n    let sn = sin(r * 0.5);\n    let cs = cos(r * 0.5);\n    return vec4f(axis * sn, cs);\n}\n\nfn quatFowardUp(f: vec3f, _up: vec3f) -> vec4f {\n    let right = normalize(cross(f, -_up));\n    let up = normalize(cross(f, right));\n\n    let m00 = right.x;\n    let m01 = right.y;\n    let m02 = right.z;\n    let m10 = up.x;\n    let m11 = up.y;\n    let m12 = up.z;\n    let m20 = f.x;\n    let m21 = f.y;\n    let m22 = f.z;\n\n    let num8 = (m00 + m11) + m22;\n    var q = vec4f(0.0, 0.0, 0.0, 1.0);\n    if (num8 > 0.0) {\n        var num = sqrt(num8 + 1.0);\n        q.w = num * 0.5;\n        num = 0.5 / num;\n        q.x = (m12 - m21) * num;\n        q.y = (m20 - m02) * num;\n        q.z = (m01 - m10) * num;\n        return q;\n    }\n\n    if ((m00 >= m11) && (m00 >= m22)) {\n        let num7 = sqrt(((1.0 + m00) - m11) - m22);\n        let num4 = 0.5 / num7;\n        q.x = 0.5 * num7;\n        q.y = (m01 + m10) * num4;\n        q.z = (m02 + m20) * num4;\n        q.w = (m12 - m21) * num4;\n        return q;\n    }\n\n    if (m11 > m22) {\n        let num6 = sqrt(((1.0 + m11) - m00) - m22);\n        let num3 = 0.5 / num6;\n        q.x = (m10 + m01) * num3;\n        q.y = 0.5 * num6;\n        q.z = (m21 + m12) * num3;\n        q.w = (m20 - m02) * num3;\n        return q;\n    }\n\n    let num5 = sqrt(((1.0 + m22) - m00) - m11);\n    let num2 = 0.5 / num5;\n    q.x = (m20 + m02) * num2;\n    q.y = (m21 + m12) * num2;\n    q.z = 0.5 * num5;\n    q.w = (m01 - m10) * num2;\n    return q;\n}\n","lygia::math::quintic":"/*\ncontributors: Inigo Quiles\ndescription: quintic polynomial https://iquilezles.org/articles/smoothsteps/\n*/\n\nfn quintic(v: f32) -> f32 { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nfn quintic2(v: vec2f) -> vec2f { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nfn quintic3(v: vec3f) -> vec3f { return v*v*v*(v*(v*6.0-15.0)+10.0); }\nfn quintic4(v: vec4f) -> vec4f { return v*v*v*(v*(v*6.0-15.0)+10.0); }\n","lygia::math::rotate2d":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 2x2 rotation matrix\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rotate2d(radians: f32) -> mat2x2<f32> {\n    let c = cos(radians);\n    let s = sin(radians);\n    return mat2x2<f32>(c, -s, s, c);\n}\n","lygia::math::rotate3d":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 3x3 rotation matrix\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rotate3d(a: vec3f, r: f32) -> mat3x3<f32> {\n    let s = sin(r);\n    let c = cos(r);\n    let oc = 1.0 - c;\n    return mat3x3<f32>( oc * a.x * a.x + c,         oc * a.x * a.y - a.z * s,   oc * a.z * a.x + a.y * s,\n                        oc * a.x * a.y + a.z * s,   oc * a.y * a.y + c,         oc * a.y * a.z - a.x * s,\n                        oc * a.z * a.x - a.y * s,   oc * a.y * a.z + a.x * s,   oc * a.z * a.z + c );\n}\n","lygia::math::rotate3dX":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 3x3 rotation matrix\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rotate3dX(r: f32) -> mat3x3<f32> {\n    return mat3x3<f32>( vec3f(1.0, 0.0, 0.0),\n                        vec3f(0.0, cos(r), -sin(r)),\n                        vec3f(0.0, sin(r), cos(r)) );\n}\n","lygia::math::rotate3dY":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 3x3 rotation matrix\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rotate3dY(r: f32) -> mat3x3<f32> {\n    return mat3x3<f32>( vec3f(cos(r), 0.0, -sin(r)),\n                        vec3f(0.0, 1.0, 0.0),\n                        vec3f(sin(r), 0.0, cos(r)) );\n}\n","lygia::math::rotate3dZ":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 3x3 rotation matrix\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rotate3dZ(r: f32) -> mat3x3<f32> {\n    return mat3x3<f32>( vec3f(cos(r), -sin(r), 0.0),\n                        vec3f(sin(r), cos(r), 0.0),\n                        vec3f(0.0, 0.0, 1.0) );\n}\n","lygia::math::rotate4d":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rotate4d(a: vec3f, r: f32) -> mat4x4<f32> {\n    let s = sin(r);\n    let c = cos(r);\n    let oc = 1.0 - c;\n    return mat4x4<f32>( oc * a.x * a.x + c,         oc * a.x * a.y - a.z * s,   oc * a.z * a.x + a.y * s,   0.0,\n                        oc * a.x * a.y + a.z * s,   oc * a.y * a.y + c,         oc * a.y * a.z - a.x * s,   0.0,\n                        oc * a.z * a.x - a.y * s,   oc * a.y * a.z + a.x * s,   oc * a.z * a.z + c,         0.0,\n                        0.0,                        0.0,                        0.0,                        1.0);\n}\n","lygia::math::rotate4dX":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rotate4dX(r: f32) -> mat4x4<f32> {\n    return mat4x4<f32>( vec4f(1.,0.,0.,0),\n                        vec4f(0.,cos(r),-sin(r),0.),\n                        vec4f(0.,sin(r),cos(r),0.),\n                        vec4f(0.,0.,0.,1.) );\n}\n","lygia::math::rotate4dY":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rotate4dY(r: f32) -> mat4x4<f32> {\n    return mat4x4<f32>( vec4f(cos(r),0.,-sin(r),0),\n                        vec4f(0.,1.,0.,0.),\n                        vec4f(sin(r),0.,cos(r),0.),\n                        vec4f(0.,0.,0.,1.) );\n}\n","lygia::math::rotate4dZ":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rotate4dZ(r: f32) -> mat4x4<f32> {\n    return mat4x4<f32>( vec4f(cos(r),-sin(r),0.,0),\n                        vec4f(sin(r),cos(r),0.,0.),\n                        vec4f(0.,0.,1.,0.),\n                        vec4f(0.,0.,0.,1.) );\n}\n","lygia::math::round":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: round a value to the nearest integer\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn round(x: f32) -> f32 { return sign(x)*floor(abs(x)+0.5); }\nfn round2(x: vec2f) -> vec2f { return sign(x)*floor(abs(x)+0.5); }\nfn round3(x: vec3f) -> vec3f { return sign(x)*floor(abs(x)+0.5); }\nfn round4(x: vec4f) -> vec4f { return sign(x)*floor(abs(x)+0.5); }\n","lygia::math::scale2d":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 2x2 scale matrix\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn scale2d(s: vec2f) -> mat2x2<f32> { return mat2x2<f32>(s.x, 0.0, 0.0, s.y); }\n","lygia::math::scale3d":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 3x3 scale matrix\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn scale3d(s: vec3f) -> mat3x3<f32> {\n    return mat3x3<f32>( s.x, 0.0, 0.0,\n                        0.0, s.y, 0.0,\n                        0.0, 0.0, s.z );\n}\n","lygia::math::scale4d":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 4x4 scale matrix\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn scale4d(s: vec3f) -> mat4x4<f32> {\n    return mat4x4<f32>( s.x, 0.0, 0.0, 0.0,\n                        0.0, s.y, 0.0, 0.0,\n                        0.0, 0.0, s.z, 0.0,\n                        0.0, 0.0, 0.0, 1.0 );\n}\n","lygia::math::smootherstep":"import package::math::quintic::{quintic, quintic2, quintic3, quintic4};\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: quintic polynomial step function\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn smootherstep(a: f32, b: f32, v: f32) -> f32 { return quintic( saturate( (v - a)/(b - a) )); }\nfn smootherstep2(a: vec2f, b: vec2f, v: vec2f) -> vec2f { return quintic2( saturate( (v - a)/(b - a) )); }\nfn smootherstep3(a: vec3f, b: vec3f, v: vec3f) -> vec3f { return quintic3( saturate( (v - a)/(b - a) )); }\nfn smootherstep4(a: vec4f, b: vec4f, v: vec4f) -> vec4f { return quintic4( saturate( (v - a)/(b - a) )); }\n","lygia::math::sum":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Sum elements of a vector\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn sum(v: f32 ) -> f32 { return v; }\nfn sum2(v: vec2f ) -> f32 { return v.x+v.y; }\nfn sum3(v: vec3f ) -> f32 { return v.x+v.y+v.z; }\nfn sum4(v: vec4f ) -> f32 { return v.x+v.y+v.z+v.w; }\n","lygia::math::taylorInvSqrt":"/*\ncontributors: [Stefan Gustavson, Ian McEwan]\ndescription: Fast, accurate inverse square root. \n*/\n\nfn taylorInvSqrt(r: f32) -> f32 { return 1.79284291400159 - 0.85373472095314 * r; }\nfn taylorInvSqrt2(r: vec2f) -> vec2f { return 1.79284291400159 - 0.85373472095314 * r; }\nfn taylorInvSqrt3(r: vec3f) -> vec3f { return 1.79284291400159 - 0.85373472095314 * r; }\nfn taylorInvSqrt4(r: vec4f) -> vec4f { return 1.79284291400159 - 0.85373472095314 * r; }\n","lygia::math::toMat4":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: given a 3x3 returns a 4x4\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn toMat4(m: mat3x3<f32>) -> mat4x4<f32> {\n    return mat4x4<f32>( vec4f(m[0], 0.0), \n                        vec4f(m[1], 0.0), \n                        vec4f(m[2], 0.0), \n                        vec4f(0.0, 0.0, 0.0, 1.0) );\n}\n","lygia::math::translate4d":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 4x4 translate matrix\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn translate4d(t: vec3f) -> mat4x4<f32> {\n    return mat4x4<f32>( 1.0, 0.0, 0.0, 0.0,\n                        0.0, 1.0, 0.0, 0.0,\n                        0.0, 0.0, 1.0, 0.0,\n                        t.x, t.y, t.z, 1.0 );\n}\n","lygia::math::unpack":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Unpack a 3D vector into a float. Default base is 256.0\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n// https://github.com/mrdoob/three.js/blob/acdda10d5896aa10abdf33e971951dbf7bd8f074/src/renderers/shaders/ShaderChunk/packing.glsl\n\nconst PackUpscale: f32 = 256. / 255.; // fraction -> 0..1 (including 1)\nconst UnpackDownscale: f32 = 255. / 256.; // 0..1 -> fraction (excluding 1)\nconst PackFactors = vec3f( 256. * 256. * 256., 256. * 256.,  256. );\nconst UnpackFactors = UnpackDownscale / vec4f( PackFactors, 1. );\nconst ShiftRight8: f32 = 1. / 256.;\n\nfn unpack8(v: vec3f) -> f32 {\n    let f = vec3f( 8.0, 8.0 * 8.0, 8.0 * 8.0 * 8.0 );\n    return dot(v, f) / 512.0;\n}\n\nfn unpack16(v: vec3f) -> f32 {\n    let f = vec3f( 16.0, 16.0 * 16.0, 16.0 * 16.0 * 16.0 );\n    return dot(v, f) / 4096.0;\n}\n\nfn unpack32(v: vec3f) -> f32 {\n    let f = vec3f( 32.0, 32.0 * 32.0, 32.0 * 32.0 * 32.0 );\n    return dot(v, f) / 32768.0;\n}\n\nfn unpack64(v: vec3f) -> f32 {\n    let f = vec3f( 64.0, 64.0 * 64.0, 64.0 * 64.0 * 64.0 );\n    return dot(v, f) / 262144.0;\n}\n\nfn unpack128(v: vec3f) -> f32 {\n    let f = vec3f( 128.0, 128.0 * 128.0, 128.0 * 128.0 * 128.0 );\n    return dot(v, f) / 2097152.0;\n}\n\nfn unpack256(v: vec3f) -> f32  {\n    let f = vec3f( 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\n    return dot(v, f) / 16581375.0;\n}\n\nfn unpackBase(v: vec3f, base: f32) -> f32 {\n    let base3 = base * base * base;\n    let f = vec3( base, base * base, base3);\n    return dot(v, f) / base3;\n}\n\nfn unpack(v: vec3f) -> f32 { return unpack256(v); }\n\n// https://github.com/mrdoob/three.js/blob/acdda10d5896aa10abdf33e971951dbf7bd8f074/src/renderers/shaders/ShaderChunk/packing.glsl\nfn unpack4(v: vec4f) -> f32 { return dot( v, UnpackFactors ); }\n","lygia::math::within":"/*\ncontributors: Johan Ismael\ndescription: Similar to step but for an interval instead of a threshold. Returns 1 is x is between left and right, 0 otherwise\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn within(x: f32, _min: f32, _max: f32) -> f32 {\n    return step(_min, x) * (1. - step(_max, x));\n}\n\nfn within2(x: vec2f, _min: vec2f, _max: vec2f) -> f32 {\n    let rta = step(_min, x) * (1. - step(_max, x));\n    return rta.x * rta.y;\n}\n\nfn within3(x: vec3f, _min: vec3f, _max: vec3f) -> f32 {\n    let rta = step(_min, x) * (1. - step(_max, x));\n    return rta.x * rta.y * rta.z;\n}\n\nfn within4(x: vec4f, _min: vec4f, _max: vec4f) -> f32 {\n    let rta = step(_min, x) * (1. - step(_max, x));\n    return rta.x * rta.y * rta.z * rta.w;\n}\n","lygia::sdf::boxSDF":"/*\ncontributors: Inigo Quiles\ndescription: generate the SDF of a box\n\n*/\n\nfn boxSDF( p: vec3f, b: vec3f ) -> f32 {\n    let d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(vec3f(max(d.x, 0.0), max(d.y, 0.0), max(d.z, 0.0)));\n}\n","lygia::sdf::cylinderSDF":"/*\ncontributors: Inigo Quiles\ndescription: generate the SDF of a cylinder\n\n*/\n\nfn cylinderSDF(p: vec3f, h: vec2f) -> f32 {\n    let d = abs(vec2f(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(vec2f(max(d.x, 0.0), max(d.y, 0.0)));\n}","lygia::sdf::opSubtraction":"/*\ncontributors: Inigo Quiles\ndescription: Subtraction operation of two SDFs\n\n*/\n\nfn opSubtraction( d1: f32, d2: f32 )-> f32 { return max(-d1, d2); }\n","lygia::sdf::opUnion":"/*\ncontributors: Inigo Quiles\ndescription: Union operation of two SDFs\n\n*/\n\nfn opUnion( d1: f32, d2:f32 ) -> f32 { return min(d1, d2); }\n","lygia::sdf::rectSDF":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Returns a rectangular SDF\noptions:\n    - CENTER_2D: vec2, defaults to vec2(.5)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/draw_shapes.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rectSDF_round(p: vec2f , b: vec2f, r: f32) -> f32 {\n    let d = abs(p - 0.5) * 4.2 - b + r;\n    return min(max(d.x, d.y), 0.0) + length(vec2f( max(d.x, 0.0), max(d.y, 0.0) )) - r;   \n}\n\nfn rectSDF(st: vec2f, s: vec2f) -> f32 {\n    let uv = st * 2.0 - 1.0;\n    return max( abs(uv.x / s.x),\n                abs(uv.y / s.y) );\n}\n","lygia::sdf::sphereSDF":"/*\ncontributors: Inigo Quiles\ndescription: generate the SDF of a sphere\n\n*/\n\nfn sphereSDF(p: vec3f, s: f32) -> f32 { \n    return length(p) - s; \n}\n","lygia::sdf::torusSDF":"/*\ncontributors: Inigo Quiles\ndescription: generate the SDF of a torus\n\n*/\n\nfn torusSDF(p: vec3f, t: vec2f ) -> f32 { \n    return length( vec2f(length(p.xz) - t.x, p.y) ) - t.y;\n}\n","lygia::space::fisheye2xyz":"import package::math::consts::PI;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: fisheye 2D projection to 3D vector\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn fisheye2xyz(uv: vec2f) -> vec3f {\n    let ndc = uv * 2.0 - 1.0;\n    let R = sqrt(ndc.x * ndc.x + ndc.y * ndc.y);\n    var dir = vec3(ndc.x / R, 0.0, ndc.y / R);\n    let Phi = (R) * PI * 0.52;\n    dir.y   = cos(Phi);\n    let s = sqrt(1.0 - dir.y * dir.y);\n    dir.x *= s;\n    dir.z *= s;\n    return dir;\n}\n","lygia::space::nearest":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: sampling function to make a texture behave like GL_NEAREST\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn nearest(v: vec2f, res: vec2f) -> vec2f {\n    let offset = 0.5 / (res - 1.0);\n    return floor(v * res) / res + offset;\n}\n","lygia::space::ratio":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: \"Fix the aspect ratio of a space keeping things squared for you, \\nin\\\n    \\ a similar way that aspect.glsl does, but while scaling the \\nspace to keep the\\\n    \\ entire 0.0,0.0 ~ 1.0,1.0 range visible\\n\"\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/draw_shapes.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn ratio(st: vec2f, s: vec2f) -> vec2f {\n    return mix( vec2f((st.x*s.x/s.y)-(s.x*.5-s.y*.5)/s.y,st.y),\n                vec2f(st.x,st.y*(s.y/s.x)-(s.y*.5-s.x*.5)/s.x),\n                step(s.x,s.y) );\n}\n","lygia::space::rotate":"import package::math::rotate2d::rotate2d;\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: rotate a 2D space by a radian r\noptions:\n    - CENTER_2D\n    - CENTER_3D\n    - CENTER_4D\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/draw_shapes.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn rotate(st: vec2f, radians: f32) -> vec2f {\n    return rotate2d(radians) * (st - 0.5) + 0.5;\n}\n","lygia::space::scale":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: scale a 2D space variable\noptions:\n    - CENTER_2D\n    - CENTER_3D\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nfn scale(st: vec2f, s: vec2f) -> vec2f {\n    return (st - 0.5) * s + 0.5;\n}\n","lygia::version":"/*\ncontributors: Patricio Gonzalez Vivo\ndescription: LYGIA version number\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\nconst LYGIA_VERSION_MAJOR: u32 = 1u;\nconst LYGIA_VERSION_MINOR: u32 = 3u;\nconst LYGIA_VERSION_PATCH: u32 = 3u;\n"}